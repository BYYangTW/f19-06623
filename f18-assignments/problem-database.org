#+TODO: TODO | ASSIGNED
#+OPTIONS: author:nil title:nil

This file should probably not be in the github site since it may contain solutions.


* ASSIGNED An example problem
  CLOSED: [2018-08-24 Fri 12:59]
  :PROPERTIES:
  :LABEL:    example
  :POINTS:   2
  :TYPE:     homework
  :RUBRIC:   just-technical
  :RUBRIC_CATEGORIES: technical
  :RUBRIC_WEIGHTS: 1.0
  :DUEDATE:  2018-08-24 23:59:59
  :GRADER:   John Kitchin
  :END:


Use python to add 5 and 5.

#+BEGIN_SRC ipython

#+END_SRC

* ASSIGNED Introduction to Jupyter notebooks
  CLOSED: [2018-08-24 Fri 16:14]
  :PROPERTIES:
  :LABEL:    introduction
  :POINTS:   1
  :TYPE:     homework
  :RUBRIC:   default
  :RUBRIC_CATEGORIES: technical, presentation
  :RUBRIC_WEIGHTS: 0.8, 0.2
  :DUEDATE:  2018-08-31 23:59:59
  :GRADER:   John Kitchin
  :END:

** text cells

Tell me something interesting about yourself in the next cell. You can convert it to a text cell by clicking in the cell, and then clicking on Cell -> Cell Type -> Markdown. When done, click Edit -> Insert Image and insert a recent picture of yourself.

#+BEGIN_SRC ipython

#+END_SRC

In the next cell, describe your experience with programming for solving engineering problems. For example, what courses have you taken, or languages you know, etc.

#+BEGIN_SRC ipython

#+END_SRC

In the next cell, describe what you are most concerned about for this course.

#+BEGIN_SRC ipython

#+END_SRC

** Python cells

*** A string

Fix this cell so that it prints "Hello World."

#+BEGIN_SRC ipython
print "hello world
#+END_SRC

*** A function

Define a function in this cell that implements $f(x) = x^2$. Print a few examples of how to use the function.

#+BEGIN_SRC ipython

#+END_SRC


*** A plot

Create a plot of $f(x) = x^2$ over the range $x=0..2$.

#+BEGIN_SRC ipython

#+END_SRC
* ASSIGNED Putting the fun in functions
  CLOSED: [2018-08-29 Wed 12:09]
  :PROPERTIES:
  :LABEL:    fun-1
  :POINTS:   1
  :TYPE:     homework
  :RUBRIC:   default
  :RUBRIC_CATEGORIES: technical, presentation
  :RUBRIC_WEIGHTS: 0.8, 0.2
  :DUEDATE:  2018-09-07 23:59:59
  :GRADER:   John Kitchin
  :END:

The van der Waals equation of state for a gas is defined by:

$\left(P + \frac{a}{V^2}\right)(V - b) = RT$

where $a$ and $b$ are defined by:

$a = \frac{27}{64}\left(\frac{R^2 T_c^2}{P_c}\right)$

$b = \frac{R T_c}{8 P_c}$

In these equations, $V$ is the molar volume, $P$ is the pressure, and $T$ is the temperature.

$R$ is the gas constant, $P_c$ is the critical pressure of
the gas, and $T_c$ is the critical temperature.

For ammonia, $P_c = 111.3$ atm, $T_c = 405.5$ K, and in these units, $R = 0.08206$ (atm L)/(mol K).

Suppose the temperature is 450 K, and the pressure is 56 atm. Now, the only undefined quantity is the molar volume, and we would like to solve for it. We have not learned how to do this yet, so today we will just use a graphical method to estimate how to do it.

It is not worth the effort to do all the algebra required to find $V$. Instead, we recognize that the solution will be the value of $V$ that makes the following equation true:

$f(V) = \left(P + \frac{a}{V^2}\right)(V - b) - RT = 0$

So, if we define the function above, and plot it for some range of $V$, we can graphically estimate the solution by looking on the graph where is the function equal to zero.

** Define a f(V)

Define a function for f(V) as defined above.

#+BEGIN_SRC ipython

#+END_SRC

Your function should work for a single value of $V$, or a numpy.array of values.

** Plot f(V) over a range of V, and find a solution to the equation

Make a plot for an array of $V$ values (e.g. use np.linspace to create an array).

You can estimate the solution from the graph by looking for where the function intersects the x-axis. Adjust the molar volume range so you can estimate the solution to two decimal places.

Note: you can turn grid-lines on your plot with the line ~plt.grid()~

#+BEGIN_SRC ipython

#+END_SRC


** solution                                                        :solution:

Most operators and functions work on arrays and numbers, so it doesn't take any special care in this case to write a function that works on both arrays and numbers. This function will not work on a list of volumes though.

#+BEGIN_SRC ipython
T = 450 # K
P = 56  # atm

Tc = 405.5  # K
Pc = 111.3  # atm
R = 0.08206 # (atm L)/(mol K)

def f(V):
    a = 27 / 64 * (R**2 * Tc**2) / Pc
    b = (R * Tc) / (8 * Pc)
    z = (P + a / V**2) * (V - b) - R * T
    return z  # atm L / mol
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[1]:
:END:

You can demonstrate it works on both data types like this:

#+BEGIN_SRC ipython
f(0.5)  # a single number
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[2]:
# text/plain
: -3.2532761747281285
:END:

#+BEGIN_SRC ipython
import numpy as np
f(np.array([0.5, 0.6]))
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[3]:
# text/plain
: array([-3.25327617,  1.13944127])
:END:

Note, you cannot use it on a list. See the end of the solution for a way to fix this.
#+BEGIN_SRC ipython
f([0.5, 0.6])
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[4]:
# output
:
: TypeErrorTraceback (most recent call last)
: <ipython-input-4-1b72b76b8f65> in <module>()
: ----> 1 f([0.5, 0.6])
:
: <ipython-input-1-9e1fa074cf64> in f(V)
:       9     a = 27 / 64 * (R**2 * Tc**2) / Pc
:      10     b = (R * Tc) / (8 * Pc)
: ---> 11     z = (P + a / V**2) * (V - b) - R * T
:      12     return z  # atm L / mol
:
: TypeError: unsupported operand type(s) for ** or pow(): 'list' and 'int'
:END:

To find the solution, we make an array of volumes, and then plot our function on those values.

#+BEGIN_SRC ipython
import numpy as np

%matplotlib inline
import matplotlib.pyplot as plt

V = np.linspace(0.57, 0.58)
plt.plot(V, f(V))
plt.xlabel('V (L/mol)')
plt.ylabel('z (atm L / mol)')
plt.grid()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[8]:


# image/png
[[file:obipy-resources/73232f0e737f26c048822a8e09245932-683112sI.png]]
:END:

You can see from the graph the solution is just below V = 0.575 L/mol, so to two decimal places, the solution is V = 0.57 L/mol.

You should always use full sentences in your work, and avoid typos. Imagine you are turning this in to a future boss, who will not want to see typos, and will not want to guess what they should get out of a graph. You should be specific about your interpretations.

** General comments

It is not necessary to comment every line of code. Comments like these are not helpful:

#+BEGIN_SRC ipython
a = 5 # set the variable a equal to 5
x = np.linspace(0, 1) # create an array from 0 to 1
#+END_SRC

Put blank lines in your code to separate them into logical units, e.g. a group of variable assignments, a function definition, etc. This makes your code more readable.

It is not necessary to define your function in every single code block. Define it once, and reuse it.

It is not necessary to do more than I ask in the homeworks. You don't get extra credit for it.

** Miscellaneous notes

Note that if you use a list as your argument, you will get this error:

#+BEGIN_SRC ipython
f([0.5, 0.6])
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[14]:
# output
:
: TypeErrorTraceback (most recent call last)
: <ipython-input-14-1b72b76b8f65> in <module>()
: ----> 1 f([0.5, 0.6])
:
: <ipython-input-1-b110c0b0c9e2> in f(V)
:       9     a = 27 / 64 * (R**2 * Tc**2) / Pc
:      10     b = (R * Tc) / (8 * Pc)
: ---> 11     z = (P + a / V**2) * (V - b) - R * T
:      12     return z
:
: TypeError: unsupported operand type(s) for ** or pow(): 'list' and 'int'
:END:

The problem is that you cannot do math on lists like you can with arrays. A common solution to this is to make the first line of your function convert the input to an array (see next code cell). This will convert lists to an array so that array math is possible.

#+BEGIN_SRC ipython
def f2(V):
    V = np.array(V) # make sure the input is an array
    a = 27 / 64 * (R**2 * Tc**2) / Pc
    b = (R * Tc) / (8 * Pc)
    z = (P + a / V**2) * (V - b) - R * T
    return z

# Now all three types work
f2(0.5), f2([0.5, 0.6]), f2(np.array([0.5, 0.6]))
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[6]:
# text/plain
: (-3.2532761747281285,
:  array([-3.25327617,  1.13944127]),
:  array([-3.25327617,  1.13944127]))
:END:

Note the x-ticks in this figure kind of run together and are difficult to read.

#+BEGIN_SRC ipython
V = np.linspace(0.56, 0.58)
plt.plot(V, f(V))
plt.xlabel('V (L / mol)')
plt.ylabel('z (atm L / mol)')
plt.grid()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[9]:


# image/png
[[file:obipy-resources/73232f0e737f26c048822a8e09245932-68311D3O.png]]
:END:

You can specify where you want the ticks like this. Here I put an intermediate tick that is approximately at z=0.

#+BEGIN_SRC ipython
V = np.linspace(0.56, 0.58)
plt.plot(V, f(V))
plt.xlabel('V (L/mol)')
plt.ylabel('z (atm L / mol)')
plt.grid()

plt.xticks([0.56, 0.57, 0.5748, 0.58]); # ; suppresses output of matplotlib
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[14]:


# image/png
[[file:obipy-resources/73232f0e737f26c048822a8e09245932-68311Eqt.png]]
:END:

* ASSIGNED A draining tank
  CLOSED: [2018-09-11 Tue 09:09]
  :PROPERTIES:
  :LABEL:    tank-draining
  :POINTS:   2
  :TYPE:     homework
  :RUBRIC:   default
  :RUBRIC_CATEGORIES: technical, presentation
  :RUBRIC_WEIGHTS: 0.8, 0.2
  :DUEDATE:  2018-09-13 23:59:59
  :GRADER:   Mingjie Liu
  :END:

If you have a cylindrical tank that drains through a hole in the bottom, the height of the water inside the cylinder is governed by:

$\frac{dh}{dt} = - \frac{A_h}{A_w} \sqrt{2 g h}$

Where $A_w$ is the cross-sectional area of the cylinder, $A_h$ is the area of the hole in the bottom, and $g = 32$ ft/s^{2}. Suppose the water starts at a height of 10 ft in a cylinder with a radius of 2 ft. There is a hole in the bottom with a radius of 1/2 inch.

Use ~scipy.integrate.solve_ivp~ to estimate how long it will take to drain the tank. Make a plot that shows the height as a function of time.

Note that you have to some care in selecting the integration range here; if $h$ is ever negative then you will see some warnings about invalid values in the sqrt.

#+BEGIN_SRC ipython

#+END_SRC

** solution                                                        :solution:

If we don't take some care to handle negative values in the square root, we cannot get to h=0, but we can get pretty close, e.g. 1e-12 ft. We can agree that is basically empty.

We can use an event to find the solution, and the event of interest is where the height is equal to the small number we choose, e.g. $h - 1e-12 = 0$. We want the integration to terminate at this point, so we set ~event.terminal = True~ in the code.

#+BEGIN_SRC ipython
import numpy as np
from scipy.integrate import solve_ivp

Aw = np.pi * 2**2
Ah = np.pi * (0.5 / 12)**2
g = 32  # ft / s^2

# I use a conditional statement to eliminate the warnings about negative h.
def dhdt(t, h):
    return -Ah / Aw * np.sqrt(2 * g * h)

def event(t, h):
    return h - 1e-12

event.terminal = True

h0 = np.array([10])
tspan=(0, 2000)
tval = np.linspace(*tspan)

sol = solve_ivp(dhdt, tspan, h0, t_eval=tval, events=event)

%matplotlib inline
import matplotlib.pyplot as plt
plt.plot(sol.t, sol.y.T)

plt.xlim([0, 2000])
plt.ylim([0, 10])
print(f'The tank is practically empty at tevents: {sol.t_events[0]} seconds.')
sol.message
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[98]:
# output
: The tank is practically empty at tevents: [ 1821.47179174] seconds.
: /Users/jkitchin/anaconda/lib/python3.6/site-packages/ipykernel_launcher.py:10: RuntimeWarning: invalid value encountered in sqrt
:   # Remove the CWD from sys.path while we load stuff.
: /Users/jkitchin/anaconda/lib/python3.6/site-packages/scipy/integrate/_ivp/rk.py:140: RuntimeWarning: invalid value encountered in maximum
:   scale = atol + np.maximum(np.abs(y), np.abs(y_new)) * rtol
:
# text/plain
: 'A termination event occurred.'



# image/png
[[file:obipy-resources/73232f0e737f26c048822a8e09245932-68311VBu.png]]
:END:

The RuntimeWarning above is caused by the solver making estimates of h that turn out to be negative. This doesn't affect the solution, but it is annoying to see. The issue is our ode function is only correct for h >=0. For all other h, the derivative should just be 0.

There is an analytical solution to this problem (you were not required to derive it), which is the time required to drain the tank is given by:

#+BEGIN_SRC ipython
Aw / (4 * Ah) * np.sqrt(10)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[103]:
# text/plain
: 1821.4719322569865
:END:

Some of you had an idea to eliminate the RuntimeWarning by redefining the ODE as $h' = Ah / Aw * ((2 * g * h)**2)**0.25$. This is algebraically equivalent, but as $h$ goes to zero, you may run into some numerical issues, e.g. (1e-9)**2 is 1e-18, which is /very/ small. That means we will need need extra care with the tolerances that define the accuracy of the solution. Here is a solution that increases the accuracy of the solution to get something pretty close to the previous result. Note, however, that we get a new RuntimeWarning, so it doesn't really help.

#+BEGIN_SRC ipython
import numpy as np
from scipy.integrate import solve_ivp

Aw = np.pi * 2**2
Ah = np.pi * (0.5 / 12)**2
g = 32  # ft / s^2

def dhdt(t, h):
    return -Ah / Aw * ((2 * g * h)**2)**0.25

def event(t, h):
    return h - 1e-12

event.terminal = True

h0 = np.array([10])
tspan=(0, 2000)
tval = np.linspace(*tspan)

sol = solve_ivp(dhdt, tspan, h0, t_eval=tval, events=event, rtol=1e-12, atol=1e-12)

%matplotlib inline
import matplotlib.pyplot as plt
plt.plot(sol.t, sol.y.T)

plt.xlim([0, 2000])
plt.ylim([0, 10])
print(f'The tank is practically empty at tevents: {sol.t_events[0]} seconds.')
sol.message
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[4]:
# output
: The tank is practically empty at tevents: [ 1821.47084038] seconds.
: /Users/jkitchin/anaconda/lib/python3.6/site-packages/scipy/integrate/_ivp/rk.py:145: RuntimeWarning: divide by zero encountered in double_scalars
:   max(1, SAFETY * error_norm ** (-1 / (order + 1))))
:
# text/plain
: 'A termination event occurred.'



# image/png
[[file:obipy-resources/73232f0e737f26c048822a8e09245932-68311Pap.png]]
:END:

* ASSIGNED Integration of the heat capacity
  CLOSED: [2018-09-05 Wed 13:47]
  :PROPERTIES:
  :LABEL:    shomate-integration
  :POINTS:   2
  :TYPE:     homework
  :RUBRIC:   default
  :RUBRIC_CATEGORIES: technical, presentation
  :RUBRIC_WEIGHTS: 0.8, 0.2
  :DUEDATE:  2018-09-11 23:59:59
  :GRADER:   Mingjie Liu
  :END:

From thermodynamics, the heat capacity is defined as $C_p = \left(\frac{dH}{dT}\right)_P$. That means we can calculate the heat required to change the temperature of some material from the following integral:

$H_2 - H_1 = Q = \int_{T_1}^{T_2} C_p(T) dT$

In the range of 298-1200K, the heat capacity of CO_{2} is given by a [[https://webbook.nist.gov/cgi/cbook.cgi?ID=C124389&Units=SI&Mask=1#Thermo-Gas][Shomate polynomial]]:

$C_p(t) = A + B t + C t^2 + D t^3 + E/t^2$ with units of J/mol/K.

where $t = T / 1000$, and $T$ is the temperature in K. The constants in the equation are

|   |     value |
|---+-----------|
| A |  24.99735 |
| B |  55.18696 |
| C | -33.69137 |
| D |  7.948387 |
| E | -0.136638 |
| F | -403.6075 |
| G |  228.2431 |
| H | -393.5224 |

** Integrate the heat capacity

Use this information to compute the energy (Q in kJ/mol) required to raise the temperature of CO_{2} from 300K to 600K. You should use ~scipy.integrate.quad~ to perform the integration.

#+BEGIN_SRC ipython

#+END_SRC

*** solution                                                       :solution:

#+BEGIN_SRC ipython
A =  24.99735
B =  55.18696
C = -33.69137
D =  7.948387
E = -0.136638
F = -403.6075
G =  228.2431
H = -393.5224

def Cp(T):
    t = T / 1000
    return A + B*t + C*t**2 + D*t**3 + E / t**2

from scipy.integrate import quad

dH, _ = quad(Cp, 300, 600)  # J / mol
print(f'The change in enthalpy is {dH / 1000:1.3f} kJ/mol.')
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[1]:
# output
: The change in enthalpy is 12.841 kJ/mol.
:
:END:


** Verify via \Delta H

The change in enthalpy (in kJ / mol) from standard state is

$dH − dH_{298.15}= A t + B t^2/2 + C t^3/3 + D t^4/4 − E/t + F − H$

again, $t = T / 1000$.

Use this equation to compute the change in enthalpy when you increase the temperature from 300 K to 600 K.

#+BEGIN_SRC ipython

#+END_SRC


*** solution                                                       :solution:

#+BEGIN_SRC ipython
def dH(T):
    t = T / 1000
    return A * t + B*t**2 / 2 + C * t**3 / 3 + D * t**4 / 4 - E/t + F - H

print(f'The change in enthalpy is {dH(600) - dH(300):1.3f} kJ/mol.')
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[2]:
# output
: The change in enthalpy is 12.841 kJ/mol.
:
:END:

This is the same as what we got from integrating the heat capacity. There is a subtle units issue, and that is the units of the heat capacity are J/mol/K, so the integral leads to units of J/mol, whereas the enthalpy equation has units of kJ/mol directly.

* ASSIGNED Boundary layers in fluid mechanics
  CLOSED: [2018-09-06 Thu 18:55]
  :PROPERTIES:
  :LABEL:    erf-fluids
  :POINTS:   1
  :TYPE:     homework
  :RUBRIC:   default
  :RUBRIC_CATEGORIES: technical, presentation
  :RUBRIC_WEIGHTS: 0.8, 0.2
  :DUEDATE:  2018-09-11 23:59:59
  :GRADER:   Noriyuki Yoshio
  :END:

When a plate is moved in a fluid at constant velocity, it causes the fluid to start moving with it. The velocity of the fluid changes with position away from the plate, and with time.

In this diagram, the plate is moving in the $x$ direction at a velocity of $U$. The velocity field at some time later is shown by the arrows in the middle.

image:../../../Downloads/IMG_1892.JPG

The velocity in the $x$ direction is given by this solution to the Navier Stokes equation for this problem:

$v_x(y, t) = U[1 - erf(\frac{y}{\sqrt{4 \eta t / \rho}})]$

The error function (erf) is defined as $erf(\zeta) = \sqrt{4 / \pi} \int_0^\zeta e^{-\xi^2} d\xi$.

** Plot the velocity profile

Make a plot of $v_x/U$ as a function of the combined variable $z = \frac{y}{\sqrt{4 \eta t / \rho}}$ over the range of z=0 to z=2. Use ~scipy.integrate.quad~ to evaluate the error function.

#+BEGIN_SRC ipython

#+END_SRC

Provide an interpretation of what happens near $z=2$, considering that $z$ is a function of both time and distance from the plate.

*** solution                                                       :solution:

#+BEGIN_SRC ipython
import numpy as np
from scipy.integrate import quad

z = np.linspace(0, 2)
vx = np.zeros(z.shape)

def integrand(x):
    return  np.sqrt(4 / np.pi) * np.exp(-x**2)

for i, _z in enumerate(z):
    erfz, _ = quad(integrand, 0, _z)
    vx[i] = 1 - erfz

%matplotlib inline
import matplotlib.pyplot as plt

plt.plot(z, vx)
plt.xlabel(r'$\frac{y}{\sqrt{4 \eta t / \rho}}$')
# Note: the string above has an r in front of it which indicates it is a "raw"
# string. Some of the characters, e.g. \r are special escaped characters like
# line return, and we do not want them interpreted that way. raw strings ignore
# these special escaped characters.
plt.ylabel('$v_x$')
plt.xlim([0, 2])
plt.ylim([0, 1])
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[26]:
# text/plain
: (0, 1)



# image/png
[[file:obipy-resources/73232f0e737f26c048822a8e09245932-181-m2.png]]
:END:

The interpretation near $z=2$ is that the velocity there is practically zero. At any given time, you can estimate the thickness of moving fluid, which is often called the boundary layer. This thickness grows with time, specifically with the square root of time.

** Repeat the calculation using the special erf function in scipy.special.erf

Verify the solution is equivalent to the previous one.

#+BEGIN_SRC ipython

#+END_SRC

*** solution                                                       :solution:
#+BEGIN_SRC ipython
from scipy.special import erf

vx_2 = 1 - erf(z)

plt.plot(z, vx, label='quad')
plt.plot(z, vx_2, 'r--', label='scipy.special.erf')
plt.xlabel(r'$\frac{y}{\sqrt{4 \eta t / \rho}}$')
plt.ylabel('$v_x$')
plt.xlim([0, 2])
plt.ylim([0, 1])
plt.legend()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[28]:




# image/png
[[file:obipy-resources/73232f0e737f26c048822a8e09245932-18196L.png]]
:END:

These are visually indistinguishable.
* ASSIGNED Solving nonlinear problems with an ODE                       :ode:
  CLOSED: [2018-09-14 Fri 14:19]
  :PROPERTIES:
  :LABEL:    ode-nla-1
  :POINTS:   2
  :TYPE:     homework
  :RUBRIC:   default
  :RUBRIC_CATEGORIES: technical, presentation
  :RUBRIC_WEIGHTS: 0.8, 0.2
  :DUEDATE:  2018-09-18 23:59:59
  :GRADER:   Noriyuki Yoshio
  :END:

Suppose you want to solve a difficult nonlinear algebraic equation that cannot readily be solved with algebra. For example, consider $f(x) = x e^{-x}$, and you seek to find the value of $x$ that makes this function equal to 0.1. One way to do this is to use a nonlinear algebra solver. In this problem, we will consider a way to solve it by integrating a differential equation.

The idea is to derive the derivative of the function, $f'(x)$, and then solve the initial value problem with an event function that finds the solution you want.

** First plot the function

You should plot the function to see if there is a solution. Consider an x-range from 0 to 5. Comment on whether there are any solutions, and if so how many and approximately where they are.

#+BEGIN_SRC ipython

#+END_SRC

** Derive f'(x)

This should be done by hand, and the result described in the next cell.

#+BEGIN_SRC ipython

#+END_SRC

** Solve the ode

Now that you have an $f'(x)$ Solve the initial value problem with $f(0)$ over the x-range that you plotted the original function on. Use an event function to identify points where $f(x)=0.1$.

Prepare a plot of the solution that has the following features:
1. Plot the original function provided in this problem.
2. Plot the solution you got from integrating $f'(x)$.
3. Plot where your solution points you found are.

#+BEGIN_SRC ipython

#+END_SRC


** solution                                                        :solution:

Here is the plot of the function.

   #+BEGIN_SRC ipython
import numpy as np
%matplotlib inline
import matplotlib.pyplot as plt

x = np.linspace(0, 5)
plt.plot(x, x * np.exp(-x))
plt.xlabel('x')
plt.ylabel('y')
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[19]:




# image/png
[[file:obipy-resources/73232f0e737f26c048822a8e09245932-38847flr.png]]
:END:

You can see there will be two solutions, one near x=0, and one closer to x=3.5.

You have to use the chain rule to derive $f'(x)$. It is $f'(x) = e^{-x} - x e^{-x}$. To find where the function is equal to 0.1, we use an event function. We do not make it terminal since there is more than one solution to find. We know from inspection that $f(0) = 0$.

#+BEGIN_SRC ipython
def fp(x, y):
    return np.exp(-x) + x * (-np.exp(-x))

f0 = np.array([0]) # f(0) = 0
xspan = (0, 5)
xeval, h = np.linspace(*xspan, retstep=True)

from scipy.integrate import solve_ivp

def event(x, y):
    return y - 0.1

sol = solve_ivp(fp, xspan, f0, dense_output=True, max_step=h, events=event)
print(f'There are solutions at {sol.t_events[0]}')
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[20]:
# output
: There are solutions at [ 0.11183256  3.57715207]
:
:END:

We plot the numerical solution and the original function to make sure we didn't make a mistake in the ODE, as well as the solutions here.

#+BEGIN_SRC ipython
plt.plot(sol.t, sol.y.T)
plt.plot(x, x * np.exp(-x), 'r--')
plt.plot(sol.t_events[0], sol.sol(sol.t_events[0]).T, 'ro')
plt.xlabel('x')
plt.ylabel('y')
plt.legend(['sol', 'f(x)', 'f(x) = 0.1'])
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[21]:




# image/png
[[file:obipy-resources/73232f0e737f26c048822a8e09245932-38847svx.png]]
:END:

The solution for f(x) is indistinguishable from f(x), so we have confidence that the integration worked, and we can see the solutions are in the right place.

* ASSIGNED Vibrations of CO2                                         :sysode:
  CLOSED: [2018-09-15 Sat 16:14]
  :PROPERTIES:
  :LABEL:    co2-vibrations
  :POINTS:   3
  :TYPE:     homework
  :RUBRIC:   default
  :RUBRIC_CATEGORIES: technical, presentation
  :RUBRIC_WEIGHTS: 0.8, 0.2
  :DUEDATE:  2018-09-20 23:59:59
  :GRADER:   Noriyuki Yoshio
  :END:

Molecules can be modeled as masses connected by springs. With these models, we can estimate how the atoms move and vibrate.

image:co2-spring.png

The equations of motion are defined as:

$M_O \frac{d^2x1}{dt^2} = k  (x2 - x1)$


$M_C \frac{d^2x2}{dt^2} = -k (x2 - x1) + k (x3 - x2)$

$M_O \frac{d^2x3}{dt^2} = -k (x3 - x2)$

Where $M_O=16$, $M_C=12$, and $k=48$. The $x_i$ variables represent a 1D deviation along the x-axis from the equilibrium positions of the atoms where the force is equal to zero.

** Convert this to a system of first-order differential equations

You can convert this to a system of FODEs by defining a new set of variables, e.g. $x4 = \frac{dx1}{dt}$, which can be interpreted as the velocity of the atom. Use this to derive a set of coupled first order differential equations. Write your equations here:

#+BEGIN_SRC ipython

#+END_SRC

** Find the solution to this set of ODES

Assuming that at $t=0$, $x1 = -0.1, x2=0.0, x3=0.1$, and that the initial velocities of the atoms are 0, find a solution with solve_ivp to your equations using solve_ivp up to $t=10$.

- Plot the positions (x1, x2, x3) for each atom as a function of time. Explain why they look the way they do for each atom.

#+BEGIN_SRC ipython

#+END_SRC

- Pick another set of initial conditions, make a plot, and explain why the solution looks the way it does.  Comment on any difference or lack of difference.

#+BEGIN_SRC ipython

#+END_SRC



** ASSIGNED solution                                               :solution:
   CLOSED: [2018-09-15 Sat 16:13]

To convert this to a system of first order ODEs, we define:

$x4 = x1'$

$x5 = x2'$

$x6 = x3'$

then

$x4' = k / mO * (x2 - x1)$

$x5' = 1 / mC * (-k * (x2 - x1) + k * (x3 - x2))$

$x6' = -k / mO * (x3 - x2)$

We solve the system like this.

#+BEGIN_SRC ipython
mO = 16
mC = 12

k = 48

def yp(t, X):
    x1, x2, x3, x4, x5, x6 = X
    dx1dt = x4
    dx2dt = x5
    dx3dt = x6
    dx4dt = k / mO * (x2 - x1)
    dx5dt = 1 / mC * (-k * (x2 - x1) + k * (x3 - x2))
    dx6dt = -k / mO * (x3 - x2)
    return np.array([dx1dt,
                     dx2dt,
                     dx3dt,
                     dx4dt,
                     dx5dt,
                     dx6dt])

from scipy.integrate import solve_ivp

Y0 = np.array([-0.1, 0.0, 0.1, 0, 0, 0])

tspan = (0, 30)
teval = np.linspace(*tspan, 100)

sol = solve_ivp(yp, tspan, Y0, t_eval=teval)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[22]:
:END:

To plot just the positions, we just plot the first three columns of the transposed solution.

#+BEGIN_SRC ipython
%matplotlib inline
import matplotlib.pyplot as plt

plt.plot(sol.t, sol.y[0:3].T)
plt.legend(['1', '2', '3'])
plt.xlabel('t')
plt.ylabel('x')
plt.ylim([-0.11, 0.2])
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[24]:
# text/plain
: (-0.11, 0.2)



# image/png
[[file:obipy-resources/73232f0e737f26c048822a8e09245932-38847rDH.png]]
:END:

You can see from this that atoms 1 and 3 oscillate around their equilibrium position, while atom 2 appears to be stationary. That happens because atoms 1 and 3 move symmetrically towards and away from atom 0. In the ODE for dx5dt, you can see that the right hand side simplifies to

(-k * (x2 - x1) + k * (x3 - x2)) = k * (x3 + x1)

and since x3 = -x1, it appears for this case the derivative will always be zero, and so x2 will be constant.

If you pick any non-symmetric initial conditions, then all three atoms will oscillate around.

#+BEGIN_SRC ipython
Y0 = np.array([-0.1, 0.05, 0.1, 0, 0, 0])

tspan = (0, 30)
teval = np.linspace(*tspan, 100)

sol = solve_ivp(yp, tspan, Y0, t_eval=teval)

plt.plot(sol.t, sol.y[0:3].T)
plt.legend(['1', '2', '3'])
plt.xlabel('t')
plt.ylabel('x')
plt.ylim([-0.11, 0.2])
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[26]:
# text/plain
: (-0.11, 0.2)



# image/png
[[file:obipy-resources/73232f0e737f26c048822a8e09245932-38847FYT.png]]
:END:

* ASSIGNED stirred tank heater                                       :sysode:
  CLOSED: [2018-09-14 Fri 16:40]
  :PROPERTIES:
  :LABEL:    heated-tank
  :POINTS:   2
  :TYPE:     homework
  :RUBRIC:   default
  :RUBRIC_CATEGORIES: technical, presentation
  :RUBRIC_WEIGHTS: 0.8, 0.2
  :DUEDATE:  2018-09-18 23:59:59
  :GRADER:   Noriyuki Yoshio
  :END:

# http://chemicalpdc.blogspot.com/2016/03/example-of-modeling-stirred-tank-heater.html

This tank has a heater in it and it is well-stirred. There is an inlet that allows flow into the tank, and flow out is gravity-driven.

#+attr_org: :width 300
image:./screenshots/date-14-09-2018-time-16-38-04.png


A mass balance on the tank yields:

$A \frac{dh}{dt} = F_i - c \sqrt{h}$

The energy balance yields:

$A h \frac{dT}{dt} = F_i (T_i - T) + \frac{Q}{\rho c_p}$

The following constants are provided (you can assume the units are consistent).

| constant | value |                |
|----------+-------+----------------|
| h        |       | liquid height  |
| A        |    10 | tank area      |
| c        |     1 | valve constant |
| cp       |     1 | heat capacity  |
| \rho     |     1 | density        |
| F_{i}    |     1 | flow in        |
| Q        |     1 | heat in        |

After a long time of operation, the tank has reached a steady state height of 1, and a temperature of 30 with $Ti=29$. However, at $t=0$ there is a disturbance, and suddenly $Ti=30$. Use the information above to plot the height and temperature of the tank as a function of time in separate plots, and estimate how long it will take to reach a new steady state value. Explain why the height and temperature change the way they do.

#+BEGIN_SRC ipython

#+END_SRC

** solution                                                        :solution:

Here we just setup the ODEs provided and integrate them.

#+BEGIN_SRC ipython
from scipy.integrate import solve_ivp
import numpy as np

A = 10
c = 1
cp = 1
rho = 1
Fi = 1
Ti = 30
Q = 1

def Yprime(t, Y):
    h, T = Y
    dhdt = 1 / A * (Fi - c * np.sqrt(h))
    dTdt = 1 / (A * h) * (Fi * (Ti - T) + Q / (rho * cp))
    return [dhdt, dTdt]

Y0 = (1, 30)
tspan = (0, 100)
teval, h = np.linspace(*tspan, retstep=True)

sol = solve_ivp(Yprime, tspan, Y0, t_eval=teval, max_step=h)

%matplotlib inline
import matplotlib.pyplot as plt
plt.plot(sol.t, sol.y[1].T)
plt.xlabel('t')
plt.ylabel('T')
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[27]:




# image/png
[[file:obipy-resources/73232f0e737f26c048822a8e09245932-38847SiZ.png]]
:END:

From the graph you can see the temperature will rise to about 31 degrees and reach a steady value after 60-70 time units.

* Generalized factorial function                                       :quad:

The \Gamma function is defined by:

$\Gamma(x) = \int_0^\infty e^{-t}t^{x-1} dt$

It is a generalized factorial function. When the arguments to the function are integers, the following relation is true:

$\Gamma(n + 1) = n!$

Show that this is true for the first 10 integers starting from 0. You can use the ~math.factorial~ function.

#+BEGIN_SRC ipython
from math import factorial

factorial(4)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[87]:
# text/plain
: 24
:END:

** Solution                                                        :solution:

 #+BEGIN_SRC ipython
from scipy.integrate import quad
import numpy as np

def integrand(t, x):
    return np.exp(-t) * t**(x - 1)

def Gamma(x):
    I, err = quad(integrand, 0, np.inf, args=(x, ))
    return I

print(Gamma(5), factorial(4))
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 # Out[88]:
 # output
 : 24.0 24
 :
 :END:
* cell growth

The data in the tables below, measure the growth rate of bacteria (G (cells/hour) over time. The area under the data curve should represent the total number of bacterial cells. Use this data to plot the total number of cells that have grown as a function of time.

#+BEGIN_SRC ipython
t = np.array([0, 0.25, 0.5, 0.75, 1.0, 1.25, 1.5, 1.75, 2.0, 2.25, 2.5, 2.75, 3.0, 3.25, 3.5, 3.75, 4.0])  # hours
G = np.array([0, 1, 4, 9, 15, 23, 31, 40, 48, 55, 61, 64, 63, 57, 46, 27, 0]) * 1000  # cells / hour


#+END_SRC


* ASSIGNED quiz-1
  CLOSED: [2018-09-19 Wed 08:06]
  :PROPERTIES:
  :LABEL:    quiz-1
  :POINTS:   3
  :TYPE:     quiz
  :RUBRIC:   default
  :RUBRIC_CATEGORIES: technical, presentation
  :RUBRIC_WEIGHTS: 0.8, 0.2
  :DUEDATE:  2018-09-19 10:19:59
  :GRADER:   John Kitchin
  :END:

*This is a quiz. You must work alone, and turn in only your original work.*

The shear stress constant $C$ is a function of the collective variable $Re \alpha$ in this figure (Fig 3-33 in Viscous Fluid Flow, 3rd ed. by Frank White):

image:viscous-flow-C.png


$C$ is derived from this integral:

$\left(\frac{2 Re\alpha}{3}\right)^{1/2} = \int_0^1 \frac{df}{[(1 - f)(f^2 + f + K)]^{1/2}}$

where $K = 3C / (2 Re\alpha)$. You goal in this problem is to create the figure
above for the region inside the red box. The key to finding $C$ is to first
specify a numeric value for $K$, evaluate the integral on the right hand side,
then solve for $Re \alpha$ from the left hand side, and finally, solve for $C$
using the numeric value of $K$ and the definition of $K$.

Use the information above to solve for $C$ as a function of $Re \alpha$. First, define a function:

$g(K) =  \int_0^1 \frac{df}{[(1 - f)(f^2 + f + K)]^{1/2}}$

and use it to create an array of values of $g(K)$ for $K$ in the range of 0 to 200.

#+BEGIN_SRC ipython

#+END_SRC

Next, solve the equation $\left(\frac{2 Re\alpha}{3}\right)^{1/2} = g(K)$ for the values of $Re \alpha$. There will be one $Re \alpha$ for each value in $K$.

#+BEGIN_SRC ipython

#+END_SRC

Next, using the relation $K = 3C / (2 Re\alpha)$, solve for $C$. You will have one $C$ for each value in $K$.

#+BEGIN_SRC ipython

#+END_SRC

Finally, make a plot of $C$ vs $Re \alpha$ here. Compare your result to the result in the red box and discuss any differences.

#+BEGIN_SRC ipython

#+END_SRC



** solution                                                        :solution:

The key to this problem is recognizing you need to evaluate an integral that is defined by a function. The function (the integrand) has a parameter in it (K), so you must either define the integrand as a function inside a function, or use a parameter argument. Here, I define it inside a function. Then, create an array of K values, and iterate over it to get g(K). It is not critical to print g(K) here, but it does help see that there are no inf, nan, or other weird things happening in your function.

#+BEGIN_SRC ipython
import numpy as np
from scipy.integrate import quad


def g(k):

    def integrand(f):
        return 1 / np.sqrt((1 - f) * (f**2 + f + k))

    I, err = quad(integrand, 0, 1)
    return I

K = np.linspace(0, 200)


gK = np.zeros(K.shape)

for i, k in enumerate(K):
    gK[i] = g(k)

gK
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[101]:
# text/plain
: array([ 2.62205755,  0.87536997,  0.65479423,  0.54592169,  0.47797388,
:         0.43039464,  0.39468683,  0.36661205,  0.34378759,  0.32475721,
:         0.308574  ,  0.29459204,  0.28235359,  0.27152397,  0.26185208,
:         0.25314529,  0.24525308,  0.23805586,  0.23145727,  0.22537866,
:         0.21975515,  0.21453263,  0.20966561,  0.2051155 ,  0.20084933,
:         0.19683876,  0.19305923,  0.18948938,  0.18611052,  0.1829062 ,
:         0.17986189,  0.1769647 ,  0.17420315,  0.17156698,  0.16904698,
:         0.16663486,  0.16432313,  0.16210502,  0.15997438,  0.1579256 ,
:         0.15595358,  0.15405363,  0.15222147,  0.15045317,  0.14874509,
:         0.1470939 ,  0.14549651,  0.14395005,  0.14245188,  0.14099953])
:END:

You can use simple algebra to compute Realpha. It is not necessary to use fsolve here.

#+BEGIN_SRC ipython
Realpha = gK**2 * 3 / 2
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[102]:
:END:

And again simple algebra to compute C.

#+BEGIN_SRC ipython
C = K * Realpha * 2 / 3
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[103]:
:END:

Finally, make the plot:

#+BEGIN_SRC ipython
%matplotlib inline
import matplotlib.pyplot as plt
plt.plot(Realpha, C, '.-')
plt.xlabel('$Re\\alpha$')
plt.ylabel('C')
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[105]:




# image/png
[[file:obipy-resources/73232f0e737f26c048822a8e09245932-764647vS.png]]
:END:

When asked to compare and discuss differences, you need to note if there are any differences, and then discuss what is the cause of them. This graph does /not/ look like the figure we are trying to reproduce. The point at Re\alpha=0 looks correct, and the point ner Re\alpha=10.31 looks correct, but there is a straight line from about 1 to 10 that is not like the figure. That is because there is not data calculated in this region, so the straight line is misleading. You can confirm that by using more points in the K range.

You can see from here we do not have a lot of data between Re\alpha=1 to 10, so the graph appears to be a straight line there. Evidently the first 49 points are concentrated from 0 to 1. You can make the plot a lot smoother by adding more points to the K array. It was not necessary to do that for this quiz, but you had to recognize the problem.


It is not obvious where you need all the points though. The relationship from K to Re\alpha to C is not a linear one. Let's look at the first few points:

#+BEGIN_SRC ipython
for i in range(3):
    print(f'K={K[i]:1.1f} Realpha={Realpha[i]:1.1f}, C={C[i]}')
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[112]:
# output
: K=0.0 Realpha=10.3, C=0.0
: K=4.1 Realpha=1.1, C=3.127643201519589
: K=8.2 Realpha=0.6, C=3.5000447809890454
:
:END:

This indicates that the big gap in data is between K=0 and K=4. The rest of the range is covered pretty well. There are many ways to create a better grid other than using a very large number of points. We could make a log-spaced grid, which will spread the points out more reasonably.

#+BEGIN_SRC ipython
logK = np.linspace(np.log(0.001), np.log(200))

K = np.exp(logK)

gK = np.zeros(K.shape)

for i, k in enumerate(K):
    gK[i] = g(k)

Realpha = gK**2 * 3 / 2

C = K * Realpha * 2 / 3

plt.plot(Realpha, C, '.-')
plt.xlabel('$Re\\alpha$')
plt.ylabel('C')
plt.xlim([0, 10.5])
plt.ylim([0, 4])
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[115]:
# text/plain
: (0, 4)



# image/png
[[file:obipy-resources/73232f0e737f26c048822a8e09245932-76464iOl.png]]
:END:

You can also just use /a lot/ of points, but you can see we have to use nearly 100 times more points than the log-spaced grid above, and this takes noticeably longer to run.

#+BEGIN_SRC ipython
K = np.linspace(0, 200, 5000)

gK = np.zeros(K.shape)

for i, k in enumerate(K):
    gK[i] = g(k)

Realpha = gK**2 * 3 / 2

C = K * Realpha * 2 / 3

plt.plot(Realpha, C, '.-')
plt.xlabel('$Re\\alpha$')
plt.ylabel('C')
plt.xlim([0, 10.5])
plt.ylim([0, 4])
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[116]:
# text/plain
: (0, 4)



# image/png
[[file:obipy-resources/73232f0e737f26c048822a8e09245932-76464vYr.png]]
:END:

*** General comments

1. You should focus most of your effort on getting a technically correct answer. This is 80% of your grade. If you can't get to it, then make sure it is clear to me what you were trying to do. You should do this in text though, since your code wasn't working. After you have something that works, you should make sure it is easy to follow, and presented appropriately.
2. I do not expect you to do something I have not shown you already, so fsolve is not necessary for the exam. I don't mind if you use it, but it is surely more complicated than what I had in mind. If you find yourself doing something complex, you should ask yourself if you are on the right track. Complex takes more time than simple.
3. If you found yourself flipping through the notes looking for a similar example to solve this, you are not prepared for the exam. You should recognize this is a problem to solve by quad, and from that know to create a function for the integrand, and then a loop to solve the integral many times. You could make yourself a cheatsheet with /brief/ summaries of syntax and an example problem for the main things we have done so far. This sheet should /summarize/ the notes in short form.
4. If the problem says compare/discuss, you need to do this in more than one sentence. It is not sufficient to simply note differences or features, without noting why they are or aren't important, what they are due to, etc. I cannot guess what you are thinking if you don't tell me.

* ASSIGNED Cooling a container problem                         :sysode:exam1:
  CLOSED: [2018-09-24 Mon 08:33]
  :PROPERTIES:
  :LABEL:    exam1-1
  :POINTS:   3
  :TYPE:     exam-1
  :RUBRIC:   default
  :RUBRIC_CATEGORIES: technical, presentation
  :RUBRIC_WEIGHTS: 0.8, 0.2
  :DUEDATE:  2018-09-24 20:29:59
  :GRADER:   John Kitchin
  :END:

# Adapted from Lynn Walker's assignment

*This is an exam problem. It is open note, and you may consult the internet. By turning in this problem, you agree that the work is your own, and you did not work with anyone to complete it. Anything else is considered cheating. If you see students working together on this problem, it is cheating and you should report it.*

A small container of liquid are initially at 150 °F.  To cool both the container and the liquid to room temperature (70 °F, the container is immersed in a bath at 32°F.  Balancing the rate of change of energy storage between the liquid and the container with the rate of convective heat transfer (liquid – container and container – bath) leads to a coupled system of equations, where L is the temperature of the liquid and C is the temperature of the container.  Using the parameters given, plot the temperature of the liquid and the container as a function of time.

$\frac{dL}{dt} = \frac{A_i h}{\rho_1 c_{p1} V_1}(C - L)$

$\frac{dC}{dt} = \frac{A_o h}{\rho_2 c_{p2} V_2}(32-C) + \frac{A_i h}{\rho_2 c_{p2} V_2}(L-C)$

|                          | Liquid (1) | Container (2) |
|--------------------------+------------+---------------|
| Mass density [lbm/ft3]   |         62 |           139 |
| Specific heat [Btu/lbmF] |       1.00 |           0.2 |
| Volume [ft3]             |       0.03 |         0.003 |

$A_i=0.4$ ft^{2} and $A_o=0.5$ ft^{2}
Assume $h = 8.8$ Btu/hr ft^{3} °F

** At what time should the container be removed for the liquid inside it to be at room temperature (70 °F)? What is the temperature of the container at that time?

#+BEGIN_SRC ipython

#+END_SRC

** Explain qualitatively why the two temperatures profiles look different.

#+BEGIN_SRC ipython

#+END_SRC

** What will happen to the temperatures after the container is removed from the bath?


#+BEGIN_SRC ipython

#+END_SRC

** solution                                                        :solution:

This is a standard system of ordinary differential equations. The easiest way to solve this problem is with an event that terminates when the liquid reaches 70 degrees.

   #+BEGIN_SRC ipython
import numpy as np
from scipy.integrate import solve_ivp
%matplotlib inline
import matplotlib.pyplot as plt

rho1 = 62  # lbm/ft3
rho2 = 139 # lbm/ft3

cp1 = 1    # Btu/lbmF
cp2 = 0.2  # Btu/lbmF

V1 = 0.03  # ft^3
V2 = 0.003 # ft^3

Ai = 0.4 # ft^2
Ao = 0.5 # ft^2

h = 8.8  # Btu/hr ft^{3} °F

def ode(t, Y):
    Y = np.array(Y)
    L, C = Y
    dLdt = Ai * h / (rho1 * cp1 * V1) * (C - L)
    dCdt = Ao * h / (rho2 * cp2 * V2) * (32 - C) + Ai * h / (rho2 * cp2 * V2) * (L - C)
    return dLdt, dCdt

tspan = (0, 2)
teval, dt = np.linspace(*tspan, retstep=True)

Y0 = (150, 150)

def event(t, Y):
    L, C = Y
    return L - 70

event.terminal = True

sol = solve_ivp(ode, tspan, Y0, max_step=dt, events=event, dense_output=True)
plt.plot(sol.t, sol.y.T)
plt.legend(['Liquid', 'container'])
plt.xlabel('Time')
plt.ylabel('Temperature')
te = sol.t_events[0]
le, ce = sol.sol(sol.t_events[0])
print(f'At t={te[0]:1.2f} hours the liquid temperature is {le[0]:1.1f} °F. The container is at {ce[0]:1.1f} °F.')
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[1]:
# output
: At t=1.10 hours the liquid temperature is 70.0 °F. The container is at 49.1 °F.
:


# image/png
[[file:obipy-resources/73232f0e737f26c048822a8e09245932-26729WrS.png]]
:END:

The container drops in temperature very quickly because it has a very low specific heat, and a very low volume. It also has the largest ΔT to drive the temperature change. On the liquid side, the heat capacity is higher, the volume is larger so its temperature goes down more slowly. The container is lower in temperature because it is in direct contact with the cooling water, whereas the liquid has to lose heat through the container.

Once the container is removed, it will quickly warm up to about 70 degF, and the liquid will cool slightly. At longer time, the whole system will reach room temperature.

*** Common mistakes

Many of you inadvertently did something like this:

#+BEGIN_SRC ipython
h = 8.8
teval, h = np.linspace(0, 10)
#+END_SRC

The problem with this is ~h~ gets redefined in the second line, so your answers become incorrect. This kind of error is difficult to catch and can only be avoided by using more descriptive (i.e. longer variable names).

Another common issue was in the explanation section. It is not sufficient to simply say the parameters are different. You need to say how they differ, and /why/ those differences matter. I can see that the parameters are different, but that does not tell me (or anyone else) why they matter.


* ASSIGNED Orthogonality of Legendre polynomials                 :quad:exam1:
  CLOSED: [2018-09-23 Sun 18:34]
  :PROPERTIES:
  :LABEL:    exam1-2
  :POINTS:   2
  :TYPE:     exam-1
  :RUBRIC:   default
  :RUBRIC_CATEGORIES: technical, presentation
  :RUBRIC_WEIGHTS: 0.8, 0.2
  :DUEDATE:  2018-09-24 20:29:59
  :GRADER:   John Kitchin
  :END:

*This is an exam problem. It is open note, and you may consult the internet. By turning in this problem, you agree that the work is your own, and you did not work with anyone to complete it. Anything else is considered cheating. If you see students working together on this problem, it is cheating and you should report it.*

The Legendre polynomials are defined by:

$P_n(x) = \sum_{m=0}^M (-1)^m \frac{(2n - 2m)!}{2^n m! (n-m)!(n - 2m)!} x^{n-2m}$

where $M= n/2$ if n is even or $(n-1) / 2$ if $n$ is odd. $m!$ means "the factorial of m", for example, 4! = 1 * 2 * 3 * 4 = 24. You can compute it like this:

#+BEGIN_SRC ipython
from math import factorial
factorial(4)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[1]:
# text/plain
: 24
:END:

Here is a helpful function to compute $M$:

#+BEGIN_SRC ipython
import numpy as np
def M(n):
    if np.mod(n, 2) == 0:  # this means n is even.
        return int(n / 2)
    else:
        return int((n - 1) / 2)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[22]:
:END:


Write a function that computes ~P(x, n)~, and plot the function for ~n=3~ and ~n=4~ on the range of x=-1 to x=1.

#+BEGIN_SRC ipython

#+END_SRC

These polynomials are /orthogonal/ on the domain of x=-1 to 1, which means:

$\int_{-1}^{1} P_3(x) P_4(x) dx = 0$

Show that is true using your function.

#+BEGIN_SRC ipython

#+END_SRC

Discuss whether this is obvious from the graph.

#+BEGIN_SRC ipython

#+END_SRC


** solution                                                        :solution:

First, we define a function for P(x, n). You can use the M function above, or incorporate it into the function like this.

#+BEGIN_SRC ipython
import numpy as np
from math import factorial

def P(x, n):
    if n % 2 == 0:
        M = n / 2
    else:
        M = (n - 1) / 2

    result = 0.0 * x
    for m in range(0, int(M) + 1):
        fnum = factorial(2 * n - 2 * m)
        fden = 2**n * factorial(m) * factorial(n - m) * factorial(n - 2 * m)
        result += (-1)**m * fnum / fden * x**(n - 2*m)
    return result

%matplotlib inline
import matplotlib.pyplot as plt

X = np.linspace(-1, 1)
plt.plot(X, P(X, 3))
plt.plot(X, P(X, 4))
plt.legend(['$P_3$', '$P_4$'])
plt.xlabel('x')
plt.ylabel('y')
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[2]:




# image/png
[[file:obipy-resources/73232f0e737f26c048822a8e09245932-26729j1Y.png]]
:END:

To evaluate the integral, we define a function for the integrand, and then use the quad function.

#+BEGIN_SRC ipython
from scipy.integrate import quad

def P34(x):
    return P(x, 3) * P(x, 4)

I, _ = quad(P34, -1, 1)
print(f'The integral evaluates to {I}')
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[3]:
# output
: The integral evaluates to 0.0
:
:END:

If you look at the plots, you can see that P3 appears to be an odd function, and P4 is an even function. The product of an even and odd function is also an odd function. Finally, the integral of an odd function over a symmetric interval is always zero. Below is a demonstration that the product is actually odd, i.e. $f(-x) = -f(x)$.

#+BEGIN_SRC ipython
P34(-0.5), P34(0.5)
plt.plot(X, P34(X), X, -P34(-X), 'k--')
plt.xlabel('x')
plt.ylabel('y')
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[8]:




# image/png
[[file:obipy-resources/73232f0e737f26c048822a8e09245932-26729Xex.png]]
:END:


* ASSIGNED Pressure-driven flow                       :sysode:shooting:exam1:
  CLOSED: [2018-09-24 Mon 09:15]
  :PROPERTIES:
  :LABEL:    exam1-3
  :POINTS:   4
  :TYPE:     exam-1
  :RUBRIC:   default
  :RUBRIC_CATEGORIES: technical, presentation
  :RUBRIC_WEIGHTS: 0.8, 0.2
  :DUEDATE:  2018-09-24 20:29:59
  :GRADER:   John Kitchin
  :END:

*This is an exam problem. It is open note, and you may consult the internet. By turning in this problem, you agree that the work is your own, and you did not work with anyone to complete it. Anything else is considered cheating. If you see students working together on this problem, it is cheating and you should report it.*

In the pressure driven flow of a fluid with viscosity $\mu$ between two stationary plates separated by distance $d$ and driven by a pressure drop $\Delta P/\Delta x$, the governing equations on the velocity $u$ of the fluid are (assuming flow in the x-direction with the velocity varying only in the y-direction):


$\frac{\Delta P}{\Delta x} = \mu \frac{d^2u}{dy^2}$


image:plane-poiseuille.png

Unlike the initial value problems we have considered so far, we have the boundary conditions: $u(y=0) = 0$ and $u(y=d)=0$, in other words, at the walls the velocity is zero (the no-slip condition). Formally, this problem is called a boundary value problem.

First, convert this ODE to a system of first order differential equations and describe them here:

#+BEGIN_SRC ipython

#+END_SRC

Write a function that describes the system of ODEs that would be suitable for use with ~scipy.integrate.solve_ivp~. Use the following parameter values:

| parameter         | value |
|-------------------+-------|
| \Delta P/\Delta x |   -50 |
| \mu               |     2 |
| d                 |   0.2 |


#+BEGIN_SRC ipython

#+END_SRC

We only know that $u(y=0) = 0$ and $u(y=d)=0$, so we do not have enough information to directly integrate the system of ODEs. Since we have two ODEs in our system, we need two initial conditions, but we only have one, $u(y=0) = 0$; the other condition is on the other side of the plate which is not directly helpful.

However, we can still proceed with what is called the /shooting method/. In this method, we /guess/ a value for the other initial condition ($u'(0)=?$), then solve the system of ODEs to the other boundary ($y=d$). Then, we see if $u(d) = 0$. If it does, we have made the right guess, and if not, we make another guess, and repeat until we find the right value that makes $u(d) = 0$.

Use this method to estimate the velocity profile $u(y)$ between the plates. Make a plot of your solution. You do not need to exactly hit 0 at $y=d$, but you should try to get close to it.

#+BEGIN_SRC ipython

#+END_SRC


** solution                                                        :solution:

Let $v = u'$, and $v' = u''$.

Then we get two equations:

$u' = v$

$v' = \Delta P/ \Delta x / \mu$

This is a standard system of ODEs. We have to guess the value of $v(0)$ and integrate to $y=d$ to see if $u(d)=0$.

#+BEGIN_SRC ipython
import numpy as np

DeltaPDeltaX = -50
mu = 2

def ode(t, X):
    u, v = X
    dudy = v
    dvdy = DeltaPDeltaX/ mu
    return [dudy, dvdy]

d = 0.2

X0 = np.array([0, 2.5]) # iterate on the second value of this array
yspan = (0, d)
yeval, h = np.linspace(*yspan, retstep=True)

from scipy.integrate import solve_ivp
sol = solve_ivp(ode, yspan, X0, max_step=h)

%matplotlib inline
import matplotlib.pyplot as plt

plt.plot(sol.t, sol.y[0])
plt.xlabel('y')
plt.ylabel('u(y)')
plt.axhline(0)
print(sol.y[0, -1])
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[10]:
# output
: -1.75207071074e-16
:


# image/png
[[file:obipy-resources/73232f0e737f26c048822a8e09245932-26729WyG.png]]
:END:

You can see that at a guess of $v(0)=2.5$ the solution at $v(d) \approx 0$.

* ASSIGNED Center of pressure                                   :trapz:exam1:
  CLOSED: [2018-09-23 Sun 18:37]
  :PROPERTIES:
  :LABEL:    exam1-4
  :POINTS:   2
  :TYPE:     exam-1
  :RUBRIC:   default
  :RUBRIC_CATEGORIES: technical, presentation
  :RUBRIC_WEIGHTS: 0.8, 0.2
  :DUEDATE:  2018-09-24 20:29:59
  :GRADER:   John Kitchin
  :END:

*This is an exam problem. It is open note, and you may consult the internet. By turning in this problem, you agree that the work is your own, and you did not work with anyone to complete it. Anything else is considered cheating. If you see students working together on this problem, it is cheating and you should report it.*

Use the data in this figure to compute the height of the pressure center.

image:pressure-center.png

#+BEGIN_SRC ipython

#+END_SRC

** solution                                                        :solution:

The key to this problem is we have data that should be integrated. That means use ~np.trapz~ or ~scipy.integrate.simps~ to estimate the integrals.

#+BEGIN_SRC ipython
import numpy as np

h = np.array([0, 15, 35, 52, 80, 112])
p = np.array([310, 425, 530, 575, 612, 620])

num = np.trapz(h * p, h)
den = np.trapz(p, h)

print(f'The center of pressure is at {num / den:1.2f} m.')
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[5]:
# output
: The center of pressure is at 60.99 m.
:
:END:

You can also use Simpson's method. The result is similar.

#+BEGIN_SRC ipython
from scipy.integrate import simps

print(f'The center of pressure is at {simps(h * p, h) / simps(p, h):1.2f} m.')
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[6]:
# output
: The center of pressure is at 60.63 m.
:
:END:


* ASSIGNED Problem 4.2                                                  :nla:
  CLOSED: [2018-09-30 Sun 16:44]
  :PROPERTIES:
  :LABEL:    nla-pressure
  :POINTS:   2
  :TYPE:     homework
  :RUBRIC:   default
  :RUBRIC_CATEGORIES: technical, presentation
  :RUBRIC_WEIGHTS: 0.8, 0.2
  :DUEDATE:  2018-10-02 23:59:59
  :GRADER:   Mingjie Liu
  :END:

# Adapted from problem 4.2 in Cutlip

This figure shows a schematic of a pipeline that delivers constant temperature water from point 1 to point 2.


image:problem-4-2.png

The general mechanical energy balance on this system results in:

$-\frac{1}{2} \nu^2 + g \Delta z + \frac{g_C \Delta P}{\rho} + 2\frac{f_F L \nu^2}{D} = 0$

| variable | value                                        |
|----------+----------------------------------------------|
| \nu      | flow velocity (ft/s)                         |
| g        | acceleration of gravity, 32.174 ft/s^{2}     |
| \Delta z | z2 - z1                                      |
| g_{c}    | conversion factor, 32.174 ft lb_m / lb_f s^2 |
| \Delta P | p2 - p1 lb_{f} / ft^{2}                      |
| f_{F}    | Fanning friction factor (see eq)             |
| L        | length of pipe (ft)                          |
| D        | inner diameter of pipe (ft), 7.981 inches    |


Our goal is to compute the flow rate of 60 °F water through a 1000 ft long pipe. The water is pumped uphill 300 ft (i.e. z2 - z1 = 300 ft). The pressure at p1 is 150 psig, and the pressure at 2 is atmospheric pressure, so $\Delta P = -150$ psig.

The density (\rho) of water is temperature dependent. With T in °F, the density (in lb_{m}/ft^{3}) is given by:

$\rho(T) = 62.122 + 0.0122 T - (1.54e-4) T^2 + (2.65e-7) T^3 - (2.24e-10) T^4$

The Fanning friction factor depends on the Reynold's number: $Re = \frac{\nu \rho D}{\mu}$. In this equation, $\mu$ is the viscosity (in lb_{m}/ft/s), and it is also dependent of temperature:

$\ln \mu = -11.0318 + \frac{1057.51}{T + 214.624}$

When $Re < 2100$ the Fanning friction factor is defined as $f_F = 16 / Re$, but when $Re > 2100$ it has this more complex expression:

$f_F = \frac{1}{16 (\log (\frac{\epsilon / D}{3.7} - \frac{5.02}{Re} \log (\frac{\epsilon / D}{3.7} + \frac{14.5}{Re})))^2}$

In this expression, $\epsilon = 0.00015$ ft, and represents the surface roughness of the pipe.

Given this information,

1. Estimate the velocity of water in the pipe (hint: it is 11.61 ft/s)
2. Compute the mass flow of water (in lb_{m}/min) in the pipe.

Some notes:
1. In numpy, the ln(x) is computed with np.log(x).
2. In numpy, the log(x) is computed with np.log10(x).
3. 1 psig = 144 lb_{f}/ ft^{2}

#+BEGIN_SRC ipython

#+END_SRC



** solution                                                        :solution:

Here is one approach to this solution. You define functions for all the temperature dependent terms, and the friction factor. Then setup the objective function from the given equation, and use fsolve on it. The only tricky points are remembering some unit conversions.

#+BEGIN_SRC ipython
import numpy as np

D = 7.981 / 12 # ft, inner diameter

T0 = 60 # degF
p1 = 150 * 144 # lbf / ft**2
p2 = 0 #
z1 = 0 # ft
z2 = 300

deltaz = z2 - z1

g = 32.174 # ft/s**2
gc = 32.174  # ft lbm/lbf s^2

L = 1000 # ft
deltaP = p2 - p1

epsilon = 0.00015 # ft

def rho(T):
    'Density in lbm / ft^3'
    return 62.122 + 0.0122 * T -1.54e-4 * T**2 + 2.65e-7 * T**3 - 2.24e-10 * T**4

def mu(T):
    'viscosity in lb_{m}/ft/s'
    return np.exp(-11.0318 + 1057.51 / (T + 214.624))

def fF(Re):
    if Re < 2100:
        return 16 / Re
    else:
        return 1 / (16 * np.log10(epsilon / D / 3.7 - 5.02 / Re * np.log10(epsilon / D / 3.7 + 14.5 / Re))**2)

def objective(v):
    Re = v * rho(T0) * D / mu(T0)
    return -0.5 * v**2 + g * deltaz + gc * deltaP / rho(T0) + 2 * fF(Re) * L * v**2 / D

from scipy.optimize import fsolve

v, = fsolve(objective, 11)
q = v * np.pi * (D / 2)**2 * 60 * rho(60)

print(f'The velocity is {v:1.2f} ft / s, and the mass flow is {q:1.0f} lb_m / min.')
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[13]:
# output
: The velocity is 11.61 ft / s, and the mass flow is 15094 lb_m / min.
:
:END:

* ASSIGNED Compressibility factors                                      :nla:
  CLOSED: [2018-10-01 Mon 11:11]
  :PROPERTIES:
  :LABEL:    nla-compressibility
  :POINTS:   3
  :TYPE:     homework
  :RUBRIC:   default
  :RUBRIC_CATEGORIES: technical, presentation
  :RUBRIC_WEIGHTS: 0.8, 0.2
  :DUEDATE:  2018-10-04 23:59:59
  :GRADER:   Mingjie Liu
  :END:

# Adapted from problem 2.1 in Cutlip

The van der Waals equation of state for a gas is defined by:

$\left(P + \frac{a}{V^2}\right)(V - b) = RT$

where $a$ and $b$ are defined by:

$a = \frac{27}{64}\left(\frac{R^2 T_c^2}{P_c}\right)$

$b = \frac{R T_c}{8 P_c}$

In these equations, $V$ is the molar volume, $P$ is the pressure, and $T$ is the temperature.

$R$ is the gas constant, $P_c$ is the critical pressure of
the gas, and $T_c$ is the critical temperature.

The compressibility factor is defined by $Z = \frac{P V}{R T}$. You can think of this as a measure how ideal the gas is; if $Z=1$ then it appears to be ideal.

For ammonia, $P_c = 111.3$ atm, $T_c = 405.5$ K, and in these units, $R = 0.08206$ (atm L)/(mol K).

Use the information above to compute the compressibility factor at the following pressures at a temperature of 450 K:

P = 56, 111.3, 222.6, 445.2, 1113, 2226 atm.

For each pressure, print the following quantities in a roughly tabular form:

P, V, Z

#+BEGIN_SRC ipython

#+END_SRC


** solution                                                        :solution:

This is like a parameterized nonlinear algebra equation that we want to solve several times for different pressures.

#+BEGIN_SRC ipython
from scipy.optimize import fsolve

T = 450
R = 0.08206
Tc, Pc = 405.5, 111.3

def vdw_zero(V, P):
    a = 27 / 64 * (R**2 * Tc**2) / Pc
    b = R * Tc / (8 * Pc)
    return (P + a/V**2) * (V - b) - R * T

# Here is one way to make a roughly tabular output.
# There are many other ways.
s = f'{"P":^6s}{"V":^6s}{"Z":^6s}'
print(s)
print('-' * len(s))
for p in [56, 111.3, 222.6, 445.2, 1113, 2226]:
    V, = fsolve(vdw_zero, 0.5, args=(p,))
    Z = p * V / R / T
    print(f'{p:6.1f}{V:6.3f}{Z:6.3f}')
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[23]:
# output
:   P     V     Z
: ------------------
:   56.0 0.575 0.872
:  111.3 0.234 0.704
:  222.6 0.077 0.466
:  445.2 0.061 0.731
: 1113.0 0.051 1.533
: 2226.0 0.046 2.783
:
:END:


* ASSIGNED System nla                                               :nla:sys:
  CLOSED: [2018-10-01 Mon 11:11]
  :PROPERTIES:
  :LABEL:    nla-sys-1
  :POINTS:   3
  :TYPE:     homework
  :RUBRIC:   default
  :RUBRIC_CATEGORIES: technical, presentation
  :RUBRIC_WEIGHTS: 0.8, 0.2
  :DUEDATE:  2018-10-04 23:59:59
  :GRADER:   Mingjie Liu
  :END:

There are two balls on trajectories in the /xy/ plane. One ball's trajectory follows the equation:

$y = x^2 - 2x + 1$

The other ball follows a trajectory of:

$9 (x-2)^2 + 4 (y-2)^2 - 36 = 0$

Determine if it is possible for the balls to ever collide (i.e. that they have the same (x, y) coordinates at the same time). You should demonstrate graphically how many possible collisions there are, and find all of them, and plot them on your graph.

It is not obvious how to plot an ellipse, so, note that the general equation for an ellipse is:

$\frac{(x-h)^2}{a^2} + \frac{(y-k)^2}{b^2} = 1$

Then, you can plot the parametric equations:

$x = h + a cos(t)$ and $y = k + b sin(t)$

so, for a circle of radius 1, centered at the point (0.5, 2) we have:

#+BEGIN_SRC ipython
import numpy as np
%matplotlib inline
import matplotlib.pyplot as plt

t = np.linspace(0, 2 * np.pi)

h, a = 0.5, 1
k, b = 2.0, 1
x = h + a * np.cos(t)
y = k + b * np.sin(t)
plt.plot(x, y)
plt.axis('equal')
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[2]:
# text/plain
: (-0.59784266238785322,
:  1.5998972696375169,
:  0.90056516217924332,
:  3.0994348378207563)



# image/png
[[file:obipy-resources/73232f0e737f26c048822a8e09245932-26729imp.png]]
:END:


#+BEGIN_SRC ipython

#+END_SRC

** solution                                                        :solution:

Here is the plot.

#+BEGIN_SRC ipython
import numpy as np
%matplotlib inline
import matplotlib.pyplot as plt

def f1(X):
    return y - x**2 - 2 * x + 1

h = 2
a = np.sqrt((36 / 9))

k = 2
b = np.sqrt((36 / 4))

t = np.linspace(0, 2 * np.pi)
x = h + a * np.cos(t)
y = k + b * np.sin(t)
plt.plot(x, y)
plt.plot(x, x**2 - 2 * x + 1, 'r-')
plt.xlabel('x')
plt.ylabel('y')
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[29]:




# image/png
[[file:obipy-resources/73232f0e737f26c048822a8e09245932-26729wGT.png]]
:END:

You can see there are two equations, near (0.2, 1) and (3.2, 4). We can use these as guesses

#+BEGIN_SRC ipython
def objective(X):
    x, y = X
    z1 = y - x**2 +2 * x - 1
    z2 = 9 * (x - 2)**2 + 4 * (y-2)**2 - 36
    return [z1, z2]

from scipy.optimize import fsolve

ans1 = fsolve(objective, [0.2, 1])
ans2 = fsolve(objective, [3.2, 4])

print(f'Ans1 is at {ans1}. Ans2 is at {ans2}.')

plt.plot(x, y)
plt.plot(x, x**2 - 2 * x + 1, 'r-')
plt.plot(*ans1, 'ro', label='root 1')
plt.plot(*ans2, 'go', label='root 2')
plt.legend()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[33]:
# output
: Ans1 is at [ 0.23800568  0.58063535]. Ans2 is at [ 3.11830088  4.48719863].
:




# image/png
[[file:obipy-resources/73232f0e737f26c048822a8e09245932-26729Kbf.png]]
:END:



#+BEGIN_SRC ipython

#+END_SRC

#+RESULTS:
:RESULTS:
# Out[26]:
# text/plain
: array([ 3.11830088,  4.48719863])
:END:

* Maximum moles of CO2                                                  :nla:

# Adapted from Cutlip 2.9
It is proposed to store CO2 at 300K in a tank with a volume of 2.5 m^{3}. The maximum pressure the tank can withstand is 100 atm. Determine the maximum number of moles that can be stored in the tank.

The equation of state for CO2 is described by the Soave-Redlich-Kwong equation:

$P = \frac{R T}{V - b} - \frac{\alpha a}{V (V + b)}$

The constants are:

$a = 0.42747 \left(\frac{R^2T_C^2}{P_C}\right)$

$b = 0.08664 \left(\frac{R T_C}{P_C}\right)$

$\alpha = (1 + m (1 - \sqrt{T / T_C})^2$

$m = 0.48508 + 1.55171 \omega - 0.1561 \omega^2$.

For CO2, $T_C=304.2$ K, $P_C = 72.9$ atm, and $\omega=0.225$.

Compare your answer to what you would estimate from the ideal gas law. Discuss what the difference means. You must say more than CO2 is not ideal. For example, what are the consequences of using the ideal gas law, vs. the equation of state?

#+BEGIN_SRC ipython
import numpy as np

Tc = 304.2
Pc = 72.9
omega = 0.225
R = 0.08206  # L atm / gmol / K

T = 300
vtank = 2.5 * 1000 # L
P = 100 # atm

a = 0.42747 * R**2 * Tc**2 / Pc
b = 0.08664 * R * Tc / Pc
m = 0.48508 + 1.55171 * omega - 0.1561 * omega**2
alpha = (1 + m * (1 - np.sqrt(T / Tc)))**2

def srw(n):
    V = vtank / n
    z = P - (R * T)/(V - b) + alpha * a / (V * (V + b))
    return z


max_moles, = fsolve(srw, 31000)
print(f'The max_moles is {max_moles:1.1f} moles.')
print(f'That is {max_moles * 44 / 1000} kg of CO2')
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[38]:
# output
: The max_moles is 38993.4 moles.
: That is 1715.7094489814024 kg of CO2
:
:END:
* bubble point for an ideal binary mixture                              :nla:

# Adapted from 2.10 in cutlip

Compute the bubble point temperature and equilibrium compositions of the
gas-phase of an ideal liquid mixutre of 10 mol% n-pentane and 90 mol% hexane at
1 atm (760 mm Hg).

The vapor pressure of n-pentane, $P_A^*$ in mm Hg is calculated with T in
°C:

$\log P_A^* = 6.85221 - \frac{1064.63}{T + 232}$

The vapor pressure of n-hexane, $P_B^*$ in mm Hg is calculated with T in °C:

$\log P_B^* = 6.87776 - \frac{1171.53}{T + 224.336}$

At the bubble point, the sum of the partial vapor pressures must equal the total pressure.

So, we need to find a temperature that makes this true.

$x_A P_A^* + (1 - x_A) P_B^* = 760$

Then, we can use Raoult's law to get the gas phase composition:

$y_i = x_i P_i^& / 760$.

#+BEGIN_SRC ipython
import numpy as np
from scipy.optimize import fsolve

def PvapA(T):
    return 10**(6.85221 - 1064.63 / (T + 232))

def PvapB(T):
    return 10**(6.87776 - 1171.53 / (T + 224.336))

xA = 0.1
def objective(T):
    return xA * PvapA(T) + (1 - xA) * PvapB(T) - 760

Tbp, = fsolve(objective, 60)

ya = xA * PvapA(Tbp) / 760
yb = 1 - ya

print(f'T_{{bubble pressure}} = {Tbp} K')
print(f'yA = {ya:1.2f}, yB = {yb:1.2f}')
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[8]:
# output
: T_{bubble pressure} = 63.68823955957572 K
: yA = 0.23, yB = 0.77
:
:END:
* dew point for ideal binary mixture                                    :nla:

Calculate the dew point temperature for a gas mixture containing 10 mol%
n-pentane, 10 mol% n-hexane and balance of nitrogen (non-condensable) at 1 atm.

#+BEGIN_SRC ipython
import numpy as np
from scipy.optimize import fsolve

def PvapA(T):
    return 10**(6.85221 - 1064.63 / (T + 232))

def PvapB(T):
    return 10**(6.87776 - 1171.53 / (T + 224.336))

ya = 0.1
yb = 0.1

def objective(T):
    xA = 760 * ya / PvapA(T)
    xB = 760 * yb / PvapB(T)
    return xA + xB - 1

fsolve(objective, 30)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[9]:
# text/plain
: array([ 15.19278479])
:END:

* bubble point and dew point of ideal multicomponent mixture            :nla:

# adapted from 2.12 in Cutlip

#+BEGIN_SRC ipython
import numpy as np
from scipy.optimize import fsolve

def antoine(T, A, B, C):
    return 10**(A + B / (T + C))

# Note this is another style of unpacking.
x = 0.1, 0.2, 0.3, 0.2, 0.2

# Bubble point
def objective(T):
    pa = antoine(T, 6.61184, -389.93, 266)
    pb = antoine(T, 6.80266, -656.54, 256)
    pc = antoine(T, 6.82973, -813.2, 248)
    pd = antoine(T, 6.83029, -945.9, 240)
    pe = antoine(T, 6.85221, -1064.63, 232)
    pvap = np.array([pa, pb, pc, pd, pe])
    return np.dot(x, pvap) - 760

fsolve(objective, 50)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[43]:
# text/plain
: array([-123.65781228])
:END:


#+BEGIN_SRC ipython
ya, yb, yc, yd, ye = 0.1, 0.2, 0.3, 0.2, 0.2

# dew point
def objective(T):
    pa = antoine(T, 6.61184, -389.93, 266)
    pb = antoine(T, 6.80266, -656.54, 256)
    pc = antoine(T, 6.82973, -813.2, 248)
    pd = antoine(T, 6.83029, -945.9, 240)
    pe = antoine(T, 6.85221, -1064.63, 232)

    xa = 760 * ya / pa
    xb = 760 * yb / pb
    xc = 760 * yc / pc
    xd = 760 * yd / pd
    xe = 760 * ye / pe
    return 1 - (xa + xb + xc + xd + xe)

fsolve(objective, -100)

objective(2.20727282)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[4]:
# text/plain
: -3.580868934704995e-11
:END:

so around 2 degF, we would start to get condensation.

I have to look up how to interpret this. I think it makes sense, there are some
heavy hydrocarbons that should condense, and they are at low mole fractions so

There is nothing particularly wrong with the solution above, but it is not as
concise as it could be, and it repeats chunks of code with minor variations. To fix this, we need better planning, some hind-sight, and some new Python syntax.

#+BEGIN_SRC ipython
import numpy as np
from scipy.optimize import fsolve

y = np.array([0.1, 0.2, 0.3, 0.2, 0.2])

pars = [[6.61184, -389.93, 266],
        [6.80266, -656.54, 256],
        [6.82973, -813.2, 248],
        [6.83029, -945.9, 240],
        [6.85221, -1064.63, 232]]


def antoine(T, A, B, C):
    return 10**(A + B / (T + C))


def Pvaps(T):
    return np.array([antoine(T, *par) for par in pars])


def xf(T):
    return 760 / Pvaps(T) * y

# It turns out vectorize is important here.
@np.vectorize
def objective2(T):
    return 1 - xf(T).sum()


T = np.linspace(0, 5)

%matplotlib inline
import matplotlib.pyplot as plt
plt.plot(T, objective(T))

fsolve(objective2, 2)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[42]:
# text/plain
: array([ 2.20727282])



# image/png
[[file:obipy-resources/73232f0e737f26c048822a8e09245932-972zA2.png]]
:END:

#+BEGIN_SRC ipython
objective(47.20610047)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[20]:
# text/plain
: 0.79393259049179754
:END:
* ASSIGNED flow between plates                                          :bvp:
  CLOSED: [2018-10-08 Mon 10:38]
  :PROPERTIES:
  :LABEL:    bvp-1
  :POINTS:   2
  :TYPE:     homework
  :RUBRIC:   default
  :RUBRIC_CATEGORIES: technical, presentation
  :RUBRIC_WEIGHTS: 0.8, 0.2
  :DUEDATE:  2018-10-09 23:59:59
  :GRADER:   Noriyuki Yoshio
  :END:

The flow of an incompressible fluid between two solid plates and driven by a pressure drop is given by:

$\frac{d^2 v}{dy^2} = \frac{\Delta P}{\mu L}$

where v(y) is the velocity in the flow direction (x) as a function of position between the plates. The fluid is glycerol with a viscosity $\mu = 0.9$ Pa-s., the gap between the plates is 0.5 mm and the pressure drop $\frac{\Delta P}{L}$ is 200 MPa / m.  Calculate the velocity profile using solve_bvp for the situation that (a) both plates are stationary and (b) for the situation that the upper plate is stationary and the bottom plate is moving at 10 m/s in the opposite direction as the pressure drop; plot these together on the same plot.


** solution                                                        :solution:

Let

$v1 = v$

$v1' = v'$

$v2 = v1'$
$v2' = v''$

$v1' = v2$
$v2' = \frac{\Delta P}{\mu L}$

We have to define boundary conditions:

Case a)
$v1(0) = 0$

$v1(L) = 0$

case b)
$v1(0) = -10$

$v1(L) = 0$


#+BEGIN_SRC ipython
import numpy as np
%matplotlib inline
import matplotlib.pyplot as plt
from scipy.integrate import solve_bvp

mu = 0.9    # Pa*s
dPL = -200e6  # Pa/m

def bvp(x, V):
    v1, v2 = V
    dv1dx = v2
    dv2dx = np.ones(x.shape) * dPL / mu
    return dv1dx, dv2dx

def bc1(Va, Vb):
    v1a, v2a = Va
    v1b, v2b = Vb
    return [v1a, v1b] # both zero

def bc2(Va, Vb):
    v1a, v2a = Va
    v1b, v2b = Vb
    return [v1a + 10, # Bottom plate moving at -10 m/s
            v1b]

L = 0.5e-3
X = np.linspace(0, L)

p = np.polyfit([0, L/2, L], [0, 6, 0], 2)
v1 = np.polyval(p, X)
v2 = np.gradient(v1, X)

V_guess = [v1, v2]

sol1 = solve_bvp(bvp, bc1, X, V_guess)
print(sol1.message)

sol2 = solve_bvp(bvp, bc2, X, V_guess)
print(sol2.message)
plt.plot(sol1.y[0], sol1.x)
plt.plot(sol2.y[0], sol2.x)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[32]:
# output
: The algorithm converged to the desired accuracy.
: The algorithm converged to the desired accuracy.
:
# text/plain
: [<matplotlib.lines.Line2D at 0x114c992b0>]



# image/png
[[file:obipy-resources/73232f0e737f26c048822a8e09245932-90490fLe.png]]
:END:

* ASSIGNED Coupled reaction and transport
  CLOSED: [2018-10-07 Sun 20:19]
  :PROPERTIES:
  :LABEL:    coupled-transport-reaction
  :POINTS:   3
  :TYPE:     homework
  :RUBRIC:   default
  :RUBRIC_CATEGORIES: technical, presentation
  :RUBRIC_WEIGHTS: 0.8, 0.2
  :DUEDATE:  2018-10-09 23:59:59
  :GRADER:   Noriyuki Yoshio
  :END:

The governing equation for steady state one-dimensional transport of a species with both reaction and flow is given below.  The concentration of the species, $C(z)$, depends on the diffusivity, $D$, local fluid velocity, $\nu$ , and reaction rate constant, $k$.  This is valid over the range  $0 \le z \le L$.

$D \frac{d^2C}{dz^2} + \nu \frac{dC}{dz} - kC^n=0$

Here is a schematic of this system.

image:coupled-transport-reaction.png

Assume the reaction is first order (n=1) and plot the concentration profile C(z*) where z* = z / L using solve_bvp to get the solution.

The boundary conditions are:
C(0) = 1M and C(L) = 0.1M.

Here are some relevant constants:

|   | value                |
|---+----------------------|
| D | 10 μm^2/sec          |
| L | 1 mm                 |
| ν | 0.1 μm/sec           |
| k | 5 x 10^{-3} sec^{-1} |

#+BEGIN_SRC ipython

#+END_SRC


** Solution                                                        :solution:

Define $c1 = C$

$c1' = C'$

$c2 = c1'$

$c2' = C''$


$c1' = c2$

$D c2' + \nu c2 - kC = 0$

so:

$c2' = 1 / D * (k c1 - \nu c2)$

#+BEGIN_SRC ipython

L = 1e-3 # m
nu = 0.1e-6 # m / sec
k = 5e-3 # 1 / s
D = 10e-12 # m^2/sec

def bvp(z, C):
    c1, c2 = C
    dc1dz = c2
    dc2dz = 1 / D * (k * c1 - nu * c2)
    return dc1dz, dc2dz

def bc(Ca, Cb):
    c1a, c2a = Ca
    c1b, c2b = Cb
    return [c1a - 1e3,
            c1b - 0.1e3]

Z = np.linspace(0, L)

lp = np.polyfit([0, L], [1e3, 0.1e3], 1)
c1 = np.polyval(lp, Z)
c2 = np.ones(c1.shape)

Cguess = [c1, c2]

sol = solve_bvp(bvp, bc, Z, Cguess)
sol.message

%matplotlib inline
import matplotlib.pyplot as plt

plt.plot(sol.x / L, sol.y[0])
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[26]:
# text/plain
: [<matplotlib.lines.Line2D at 0x1145cd438>]



# image/png
[[file:obipy-resources/73232f0e737f26c048822a8e09245932-90490sOw.png]]
:END:

* ASSIGNED Tomato height model
  CLOSED: [2018-10-14 Sun 20:26]
  :PROPERTIES:
  :LABEL:    tomato-height
  :POINTS:   2
  :TYPE:     homework
  :RUBRIC:   default
  :RUBRIC_CATEGORIES: technical, presentation
  :RUBRIC_WEIGHTS: 0.8, 0.2
  :DUEDATE:  2018-10-16 23:59:59
  :GRADER:   Mingjie Liu
  :END:

The following data shows the height of a genetically modified tomato plant versus the number of weeks after it was planted outdoors.

#+BEGIN_SRC ipython
import numpy as np
week = np.array([1, 2, 4, 6, 8, 10])
height = np.array([9, 15, 22, 33, 44, 52])
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[80]:
:END:

Researchers have suggested that the S-shaped logistic curve:

$height = \frac{k}{1 + e^{a + b week}}$

would be appropriate to represent this data. Use ~scipy.optimize.minimize~ to find the parameters $k, a, b$ in this equation. Then, use the model to plot how tall the plants will be after 24 weeks.

Discuss whether you think the S-shaped logistic curve is justified for this problem compared to a simple line, and how your prediction of the height in 24 weeks might change if you chose another model.

#+BEGIN_SRC ipython

#+END_SRC


** solution                                                        :solution:

First we plot the data:

   #+BEGIN_SRC ipython
import numpy as np
%matplotlib inline
import matplotlib.pyplot as plt

week = np.array([1, 2, 4, 6, 8, 10])
height = np.array([9, 15, 22, 33, 44, 52])

plt.plot(week, height)
plt.xlabel('week')
plt.ylabel('height')
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[81]:




# image/png
[[file:obipy-resources/73232f0e737f26c048822a8e09245932-3373CBD.png]]
:END:

At first inspection, it would appear that a linear fit would be appropriate if all we are interested in is this time frame. A line, however, does not reflect the long-term growth of tomato plants; they do not get bigger for all of time.

#+BEGIN_SRC ipython
def model(w, pars):
     k, a, b = pars
     return k / (1 + np.exp(a + b * w))

def objective(pars):
    errs = model(week, pars) - height
    return np.sum(errs**2)

from scipy.optimize import minimize
sol = minimize(objective, [51, 3, -0.1])
print(sol)
plt.plot(week, height, 'bo')
wfit = np.linspace(0, 24)
plt.plot(wfit, model(wfit, sol.x))
plt.xlabel('week')
plt.ylabel('height')

print(f'After 24 weeks we expect the plant to be {model(24, sol.x):1.2f} units high.')
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[84]:
# output
:       fun: 3.805541880683797
:  hess_inv: array([[  8.26915488e+00,   1.14875473e-02,   5.27698629e-02],
:        [  1.14875473e-02,   2.83525953e-03,  -3.42810255e-04],
:        [  5.27698629e-02,  -3.42810255e-04,   4.12396575e-04]])
:       jac: array([ -2.08616257e-07,  -2.98023224e-08,  -6.25848770e-07])
:   message: 'Optimization terminated successfully.'
:      nfev: 150
:       nit: 21
:      njev: 30
:    status: 0
:   success: True
:         x: array([ 64.11025667,   2.01701274,  -0.34805578])
: After 24 weeks we expect the plant to be 64.00 units high.
:


# image/png
[[file:obipy-resources/73232f0e737f26c048822a8e09245932-3373pfV.png]]
:END:

The justification of choosing the logistic curve for fitting is based on 1) domain expertise that this function has the behavior of long-term growth of plants; and 2) based on the goal of predicting future behavior based on that model. It is apparent that the logistic function is also approximately linear in the beginning, and only at longer times becomes nonlinear.

* ASSIGNED Minimize USPS cost
  CLOSED: [2018-10-14 Sun 20:27]
  :PROPERTIES:
  :LABEL:    usps-cost
  :POINTS:   2
  :TYPE:     homework
  :RUBRIC:   default
  :RUBRIC_CATEGORIES: technical, presentation
  :RUBRIC_WEIGHTS: 0.8, 0.2
  :DUEDATE:  2018-10-16 23:59:59
  :GRADER:   Mingjie Liu
  :END:

The US Postal service (USPS) has to make decisions about how many mail carriers to employ for a given area.

Let $x$ be the number of carriers. The USPS has developed a model for the total cost as a function of $x$. The overhead cost is $u x$, and the operations cost is $c \frac{t m + k_2 \sqrt{a m}}{d - k_1 \sqrt{a / x}}$ where the constants are defined in this block.

#+BEGIN_SRC ipython
a = 400     # Land area
m = 200000  # number of customers
d = 8       # length of work day
t = 0.05    # average time to deliver one customer their mail
c = 0.1     # annual cost per carrier
u = 0.75    # annual overhead of one delivery unit
k1 = 0.2    # proportionality constant
k2 = 0.1    # proportionality constant
#+END_SRC

Define an objective function that shows how the total cost depends on the number of carriers ($x$). Plot your function and show that there is a minimum in it.

#+BEGIN_SRC ipython

#+END_SRC

Use ~scipy.optimize.minimize~ to find a quantitative value for the minimum. Discuss what your solution means and if it is practical. If it is not practical, discuss what you should do to make it work.

#+BEGIN_SRC ipython

#+END_SRC

** solution                                                        :solution:

The solution to this problem requires you to make an objective function that can be minimized, and then use minimize to find the solution.

   #+BEGIN_SRC ipython
a = 400     # Land area
m = 200000  # number of customers
d = 8       # length of work day
t = 0.05    # average time to deliver one customer their mail
c = 0.1     # annual cost per carrier
u = 0.75    # annual overhead of one delivery unit
k1 = 0.2    # proportionality constant
k2 = 0.1    # proportionality constant

def objective(x):
    overhead = u * x
    operations = c * (t * m + k2 * np.sqrt(a * m)) / (d - k1 * np.sqrt(a / x))
    return overhead + operations

minimize(objective, 10)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[17]:
# text/plain
:       fun: 167.61419781886187
:  hess_inv: array([[ 12.32254795]])
:       jac: array([ -1.90734863e-06])
:   message: 'Optimization terminated successfully.'
:      nfev: 24
:       nit: 7
:      njev: 8
:    status: 0
:   success: True
:         x: array([ 15.27328667])
:END:

The solution suggests you need 15.3 carriers, which is not practical; there is no such thing as 0.3 of a carrier. You either need 15 or 16 carriers.

* ASSIGNED Quiz 2
  CLOSED: [2018-10-22 Mon 09:34]
  :PROPERTIES:
  :LABEL:    quiz-2
  :POINTS:   3
  :TYPE:     quiz
  :RUBRIC:   default
  :RUBRIC_CATEGORIES: technical, presentation
  :RUBRIC_WEIGHTS: 0.8, 0.2
  :DUEDATE:  2018-10-22 10:20:00
  :GRADER:   John Kitchin
  :END:

The vapor pressure of water has been measured as a function of temperature in the following data:

#+BEGIN_SRC ipython
import numpy as np

# Temperature in degrees C
T = np.array([  0.,   5.,  10.,  15.,  20.,  25.,  30.,  35.,  40.,  45.,  50.,
                55.,  60.,  65.,  70.,  75.,  80.])

# Water vapor pressure in kPa
Pvap = np. array([  0.6113,   0.8726,   1.2281,   1.7056,   2.3388,   3.169 ,
          4.2455,   5.6267,   7.3814,   9.5898,  12.344 ,  15.752 ,
         19.932 ,  25.022 ,  31.176 ,  38.563 ,  47.373 ])
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[72]:
:END:

The Tetens equation:

$P = A e^{B T / (T + C)}$

is sometimes used to model temperature dependent vapor pressures. Use the data above to find the coefficients $A, B, C$. Make sure to show that your answer fits the data.

#+BEGIN_SRC ipython

#+END_SRC

Use your parameters to solve for the temperature at which the vapor pressure is 101.32 kPa. Note this should be the boiling point of water at 1 atm. Compare your answer to what you expected, and discuss reasons why there could be some differences.

#+BEGIN_SRC ipython

#+END_SRC


** Solution                                                        :solution:

I chose to use ~scipy.optimize.minimize~ to solve this problem.

#+BEGIN_SRC ipython
def model(pars, T):
    A, B, C = pars
    return A * np.exp(B * T / (T + C))

def objective(pars):
    errs = Pvap - model(pars, T)
    return np.sum(errs**2)

from scipy.optimize import minimize
%matplotlib inline
import matplotlib.pyplot as plt

sol = minimize(objective, [0.6, 20, 200])
print(sol)
plt.plot(T, Pvap, 'bo', T, model(sol.x, T))
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[73]:
# output
:       fun: 0.00012180003902405202
:  hess_inv: array([[  2.74100680e-02,   5.70396141e-01,   1.36602804e+01],
:        [  5.70396141e-01,   1.36368228e+01,   3.15978881e+02],
:        [  1.36602804e+01,   3.15978881e+02,   7.37745489e+03]])
:       jac: array([  8.20738307e-04,   1.22716443e-04,  -6.72944589e-06])
:   message: 'Desired error not necessarily achieved due to precision loss.'
:      nfev: 637
:       nit: 44
:      njev: 125
:    status: 2
:   success: False
:         x: array([   0.60699675,   17.0171794 ,  232.43079154])
:
# text/plain
: [<matplotlib.lines.Line2D at 0x114593588>,
:  <matplotlib.lines.Line2D at 0x114593ef0>]



# image/png
[[file:obipy-resources/73232f0e737f26c048822a8e09245932-3373Q3z.png]]
:END:

Note that the default solver does not claim success "due to precision loss". However, the fit appears to be fine.  What appears to happen is that there is a lot of uncertainty in one of the parameters, and the solver has detected that it is not able to get the precision it is expecting.

#+BEGIN_SRC ipython
np.sqrt(np.diag(sol.hess_inv))
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[75]:
# text/plain
: array([  0.16555986,   3.69280689,  85.89211191])
:END:

You can "fix" this problem by using another optimizer method that does not rely on the Hessian, e.g. Nelder-Mead.

#+BEGIN_SRC ipython
minimize(objective, [0.6, 20, 200], method='Nelder-Mead')
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[76]:
# text/plain
:  final_simplex: (array([[   0.60700607,   17.01738072,  232.4355726 ],
:        [   0.60700616,   17.01738344,  232.43563349],
:        [   0.60700621,   17.0173844 ,  232.4356559 ],
:        [   0.60700611,   17.01738317,  232.435622  ]]), array([ 0.0001218,  0.0001218,  0.0001218,  0.0001218]))
:            fun: 0.00012179836738110874
:        message: 'Optimization terminated successfully.'
:           nfev: 223
:            nit: 124
:         status: 0
:        success: True
:              x: array([   0.60700607,   17.01738072,  232.4355726 ])
:END:

You can see from this that the parameters are practically identical, so the warning from the default solver can be ignored.

To find the boiling point we use ~scipy.optimize.fsolve~.

#+BEGIN_SRC ipython
from scipy.optimize import fsolve

def obj(T):
    return 101.32 - model(sol.x, T)

Tboil, = fsolve(obj, 100)
print(f'The boiling point is estimated to be {Tboil:1.2f} degC.')
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[79]:
# output
: The boiling point is estimated to be 99.96 degC.
:
:END:

This is practically what we expect for the boiling point of water. Off the top of my head, I expected 100 degC to be the boiling point of water at 1 atm. It is not, however. The /normal boiling point/ of water at 1atm is really 99.97 degC (https://en.wikipedia.org/wiki/Boiling_point#Saturation_temperature_and_pressure). So, our answer is quite close indeed.


* ASSIGNED exam2-1
  CLOSED: [2018-10-24 Wed 06:52]
  :PROPERTIES:
  :LABEL:    exam2-1
  :POINTS:   4
  :TYPE:     exam-2
  :RUBRIC:   default
  :RUBRIC_CATEGORIES: technical, presentation
  :RUBRIC_WEIGHTS: 0.8, 0.2
  :DUEDATE:  2018-10-24 10:20:00
  :GRADER:   John Kitchin
  :END:

*This is an exam problem. It is open note, and you may consult the internet. By turning in this problem, you agree that the work is your own, and you did not work with anyone to complete it. Anything else is considered cheating. If you see students working together on this problem, it is cheating and you should report it.*

In spectroscopy, peaks are often modeled by a Lorentzian function:

$L(x) = \frac{A}{\pi}\frac{0.5 \Gamma}{(x - x_0)^2 + (0.5\Gamma)^2}$

Where $A$ is related to the intensity, \Gamma is a parameter specifying the width, and $x_0$ is the position of the peak.

In the following spectrum, there appear to be two peaks.

#+BEGIN_SRC ipython
import numpy as np
%matplotlib inline
import matplotlib.pyplot as plt

w = np.array([ 0.   ,  0.102,  0.204,  0.306,  0.408,  0.51 ,  0.612,  0.714,
               0.816,  0.918,  1.02 ,  1.122,  1.224,  1.327,  1.429,  1.531,
               1.633,  1.735,  1.837,  1.939,  2.041,  2.143,  2.245,  2.347,
               2.449,  2.551,  2.653,  2.755,  2.857,  2.959,  3.061,  3.163,
               3.265,  3.367,  3.469,  3.571,  3.673,  3.776,  3.878,  3.98 ,
               4.082,  4.184,  4.286,  4.388,  4.49 ,  4.592,  4.694,  4.796,
               4.898,  5.   ])

intensity = np.array([ 0.629,  0.559,  0.703,  0.686,  0.917,  1.018,  1.158,  1.346,
                       1.608,  1.845,  2.1  ,  2.644,  3.02 ,  3.57 ,  3.946,  4.314,
                       4.486,  4.569,  4.793,  5.03 ,  5.659,  6.436,  7.397,  8.378,
                       8.746,  8.662,  7.973,  7.018,  5.799,  4.77 ,  3.84 ,  3.184,
                       2.749,  2.221,  1.929,  1.652,  1.412,  1.156,  1.068,  0.996,
                       0.809,  0.808,  0.735,  0.65 ,  0.556,  0.605,  0.528,  0.433,
                       0.502,  0.297])
plt.plot(w, intensity)
plt.xlabel('w')
plt.ylabel('intensity')
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[40]:




# image/png
[[file:obipy-resources/73232f0e737f26c048822a8e09245932-65837NvA.png]]
:END:

Use this information to find the parameters for the two peaks. You can assume that the intensity can be modeled as $i = L(w; p1) + L(w; p2)$ where $p1, p2$ are the parameters for each Lorentzian peak.

#+BEGIN_SRC ipython

#+END_SRC

The two peaks are caused by there being two species present. The relative amounts of each species can be computed two different ways. The first way is the ratio of the $A$ parameters, which is essentially related to the heights of the peaks. Compute the ratio of the $A$ parameters to estimate the relative amounts of each species.

#+BEGIN_SRC ipython

#+END_SRC

The second way is to compute the ratio of the areas under each fitted peak. Compute this ratio, and compare it to the height ratio. Explain why the are similar in this case.

#+BEGIN_SRC ipython

#+END_SRC


** solution                                                        :solution:

We create a model function for the Lorentzian function that takes three parameters. Then, we create an objective function with 6 parameters (3 for each peak) that returns the summed squared error between the model and data.

#+BEGIN_SRC ipython
def model(pars, x):
    A, gamma, x0 = pars
    return A / np.pi * 0.5 * gamma / ((x - x0)**2 + (0.5 * gamma)**2)

def objective(pars):
    p1 = pars[0:3]
    p2 = pars[3:]
    I = model(p1, w) + model(p2, w)
    errs = I - intensity
    return np.sum(errs**2)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[34]:
:END:

Then, we use minimize to find the parameters. You can make initial guesses from inspection of the data, e.g. the location, heights and widths of the peaks.

#+BEGIN_SRC ipython
from scipy.optimize import minimize

sol = minimize(objective, [4, 2, 1.5, 10, 2.5, 2.5])
p1 = sol.x[0:3]
p2 = sol.x[3:]

fI = model(p1, w) + model(p2, w)
plt.plot(w, intensity, 'b.', w, fI)
plt.plot(w, model(p1, w), 'r-')
plt.plot(w, model(p2, w), 'g-')
plt.xlabel('w')
plt.ylabel('intensity')
plt.legend(['data', 'fit', 'peak1', 'peak2'])
p1, p2
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[39]:
# text/plain
: (array([ 3.93524231,  0.98456647,  1.49690393]),
:  array([ 13.10333468,   1.00136008,   2.49889485]))



# image/png
[[file:obipy-resources/73232f0e737f26c048822a8e09245932-65837blx.png]]
:END:

Note that you should always plot the fit, to make sure it looks good. It is also a good idea to plot the two peaks to make sure they also make sense (e.g. they are located in the right place).

#+BEGIN_SRC ipython
height_ratio = p1[0] / p2[0]
print(f'The height ratio (A1 / A2) is {height_ratio:1.2f}.')
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[42]:
# output
: The height ratio (A1 / A2) is 0.30.
:
:END:

To compute the area ratio, we need the area under each peak.

#+BEGIN_SRC ipython
from scipy.integrate import quad

def i1(x):
    return model(p1, x)
a1, _ = quad(i1, 0, 5)

def i2(x):
    return model(p2, x)
a2, _ = quad(i2, 0, 5)

print(f'The area ratio (area1 / area2) is {a1 / a2:1.2f}.')
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[44]:
# output
: The area ratio (area1 / area2) is 0.29.
:
:END:

The reason these ratios are so similar is that the peaks are symmetric, and have similar widths. If they were not this way, the ratios would not be similar.

* ASSIGNED exam2-2
  CLOSED: [2018-10-24 Wed 06:50]
  :PROPERTIES:
  :LABEL:    exam2-2
  :POINTS:   4
  :TYPE:     exam-2
  :RUBRIC:   default
  :RUBRIC_CATEGORIES: technical, presentation
  :RUBRIC_WEIGHTS: 0.8, 0.2
  :DUEDATE:  2018-10-24 10:20:00
  :GRADER:   John Kitchin
  :END:

*This is an exam problem. It is open note, and you may consult the internet. By turning in this problem, you agree that the work is your own, and you did not work with anyone to complete it. Anything else is considered cheating. If you see students working together on this problem, it is cheating and you should report it.*

Gas absorption in a liquid film can be enhanced by chemical reactions. In this example, the gas A dissolves at the surface of the liquid film and diffuses into the film.  A reaction also occurs that consumes the dissolved A: $A + B \rightarrow C$. B is not volatile though, and it does not leave the film. Within the film defined by the length scale $L$ diffusion is the only transport mechanism of A and B.

image:/Users/jkitchin/Desktop/github-f18-06623/assignments/coupled-diffusion-reaction.jpg

The concentrations of $A$ and $B$ in the region between x=0 and x=L are governed by these differential equations:

$\frac{d^2C_A}{dx^2} = \frac{k}{D_{AD}} C_A C_B$

$\frac{d^2C_B}{dx^2} = \frac{k}{D_{BD}} C_A C_B$

with boundary conditions of $C_A(x=0) = C_{As}$, $dC_B/dx (x=0) = 0$, $C_A(x=L) = 0$ and $C_B(x=L) = C_{B0}$. The values of the constants in this problem are given as:

#+BEGIN_SRC ipython
L = 2e-4     # m
Dad = 2e-10  # m^s/s
Dbd = 4e-10  # m^2/s
Cb0 = 10     # kg-mol/m^3
Cas = 10     # kg-mol/m^3
k = 1.6e-3   # m^3/(kg mol s)
#+END_SRC

Use this information to compute and plot the concentration profiles of A and B from x=0 to x=L. Show evidence that the boundary conditions are satisfied, and compute the derivative of A ($dC_A/dx$) at x=0.

#+BEGIN_SRC ipython

#+END_SRC

** solution                                                        :solution:

First we setup the system of first order equations and the boundary conditions.

We need some changes of variables:

Ca1 = Ca

Ca2 = Ca1'

Ca2' = Ca1'' = k / Dad * Ca1 * Cb1

Cb1 = Cb

Cb2 = Cb1'

Cb2' = Cb1'' = k / Dbd * Ca1 * Cb1

with boundary conditions:

Ca1(0) = Cas

Ca1(L) = 0

dCb/dx = Cb2(0) = 0

Cb2(L) = Cb0

Here are those equations in code:

#+BEGIN_SRC ipython
import numpy as np
from scipy.integrate import solve_bvp

L = 2e-4  # m
Dad = 2e-10  # m^s/s
Dbd = 4e-10  # m^2/s
Cb0 = 10 # kg-mol/m^3
Cas = 10 # kg-mol/m^3
k = 1.6e-3 # m^3/(kg mol s)

def bvp(x, C):
    Ca1, Ca2, Cb1, Cb2 = C
    dCa1dx = Ca2
    dCa2dx = k / Dad * Ca1 * Cb1
    dCb1dx = Cb2
    dCb2dx = k / Dbd * Ca1 * Cb1
    return [dCa1dx, dCa2dx, dCb1dx, dCb2dx]

def bc(Ca, Cb):
    Ca1a, Ca2a, Cb1a, Cb2a = Ca
    Ca1b, Ca2b, Cb1b, Cb2b = Cb
    # At x=0
    bc1 = Cas - Ca1a  # Ca(x=0) = Cas
    bc2 = Cb2a  # dCbdx(x=0) = 0
    # at x=L
    bc3 = Ca1b  # Ca(x=L) = 0
    bc4 = Cb0 - Cb1b  # Cb(x=L) = Cb0
    return [bc1, bc2, bc3, bc4]
#+END_SRC

Next, we need initial guesses. We assume Ca decreases linearly from Cas to 0 over the L-range. We assume Cb increases linearly from 0 to Cb0 over the L-range. This does not satisfy the boundary condition at x=0 for dCb/dx, but it may work anyway.

#+BEGIN_SRC ipython
X = np.linspace(0, L)

# Guesses are lines
p1a = np.polyfit([0, L], [Cas, 0], 1)
g1a = np.polyval(p1a, X)
g2a = np.gradient(g1a, X)

p1b = np.polyfit([0, L], [0, Cb0], 1)
g1b = np.polyval(p1b, X)
g2b = np.gradient(g1b, X)

guess = np.array([g1a, g2a, g1b, g2b])

# Plot to make sure they look right.
plt.plot(X * 1000, g1a, X * 1000, g1b)
plt.xlabel('x (mm)')
plt.ylabel('C')
plt.legend(['A', 'B'])
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[47]:




# image/png
[[file:obipy-resources/73232f0e737f26c048822a8e09245932-658370NT.png]]
:END:

Finally, we solve and lot the solution.

#+BEGIN_SRC ipython
sol = solve_bvp(bvp, bc, X, guess)

# You should always check the message for success.
print(sol.message)

%matplotlib inline
import matplotlib.pyplot as plt

Ca, _, Cb, _ = sol.y
x = X * 1000
plt.plot(x, Ca, x, Cb)
plt.xlabel('x (mm)')
plt.ylabel('C')
plt.legend(['A', 'B'])
print(f'dC_A/dx at x=0 is {sol.y[1][0]:1.2f} kgmol/m^3/m')
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[18]:
# output
: The algorithm converged to the desired accuracy.
: dC_A/dx at x=0 is -82913.92 kgmol/m^3/m
:


# image/png
[[file:obipy-resources/73232f0e737f26c048822a8e09245932-65837ayS.png]]
:END:

There are a few ways to show evidence of the boundary conditions being satisfied. One way is to show the bc function is all zeros (within tolerance of course).

#+BEGIN_SRC ipython
bc(sol.y[:,0], sol.y[:, -1])
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[20]:
# text/plain
: [0.0, 0.0, -1.6767882786080825e-18, 0.0]
:END:

Or you could show them individually like this:

#+BEGIN_SRC ipython
Ca, dCadx, Cb, dCbdx = sol.y
print(f'''
Ca(0) = Cas  : {abs(Ca[0] - Cas) < 1e-6}
Ca(L) = 0    : {abs(Ca[-1] - 0) < 1e-6}
dCbdx(0) = 0 : {abs(dCbdx[0] - 0) < 1e-6}
Cb(L) = Cb0  : {abs(Cb[-1] - Cb0) < 1e-6}
''')
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[26]:
# output
:
: Ca(0) = Cas  : True
: Ca(L) = 0    : True
: dCbdx(0) = 0 : True
: Cb(L) = Cb0  : True
:
:
:END:

* ASSIGNED exam2-3
  CLOSED: [2018-10-24 Wed 06:50]
  :PROPERTIES:
  :LABEL:    exam2-3
  :POINTS:   3
  :TYPE:     exam-2
  :RUBRIC:   default
  :RUBRIC_CATEGORIES: technical, presentation
  :RUBRIC_WEIGHTS: 0.8, 0.2
  :DUEDATE:  2018-10-24 10:20:00
  :GRADER:   John Kitchin
  :END:

*This is an exam problem. It is open note, and you may consult the internet. By turning in this problem, you agree that the work is your own, and you did not work with anyone to complete it. Anything else is considered cheating. If you see students working together on this problem, it is cheating and you should report it.*

The normal distribution is defined by:

$f(x) = \frac{1}{\sigma \sqrt{2 \pi}} e^{-0.5 (x - \mu)^2/\sigma^2}$

In this equation, \mu is the average, and \sigma is the standard deviation of the distribution. For this problem, let \mu=0, and \sigma=1.

One property of this distribution is that $\int_{-\infty}^{\infty}  f(x) dx = 1$. Show that this is true by evaluating the integral.

#+BEGIN_SRC ipython

#+END_SRC

There is a guideline that \pm 2\sigma represents 95% of the distribution, i.e. it defines a 95% confidence interval. Find a solution for $x$ to this equation, which represents a symmetric fraction of the distribution that covers 95% of the area. Compare your answer to the guideline.

$0.95 = \int_{-x}^{x} f(x) dx$

#+BEGIN_SRC ipython

#+END_SRC

The mean of a continuous distribution is defined by $\mu = \int_{-\infty}^{\infty} x f(x) dx$. Show that the average of the normal distribution as defined above is zero by evaluating this integral.

#+BEGIN_SRC ipython

#+END_SRC

The variance, $\sigma^2$ is defined by $\sigma^2 = \int_{-\infty}^{\infty} (x - \mu)^2 f(x) dx$. Show that the variance of the normal distribution as defined above is one by evaluating this integral. Note that \mu=0 by the definitions above.

#+BEGIN_SRC ipython

#+END_SRC


** solution                                                        :solution:

This is a standard integral.

#+BEGIN_SRC ipython
import numpy as np
from scipy.integrate import quad

mu, sigma = 0.0, 1.0

def integrand(x):
    return np.exp(-0.5 * (x - mu)**2 / sigma**2) / (sigma * np.sqrt(2 * np.pi))

quad(integrand, -np.inf, np.inf)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[49]:
# text/plain
: (0.9999999999999998, 1.0178191320905743e-08)
:END:

You can see by inspection the first value is practically one.

To find the value of x we need to setup an objective function and use fsolve.

#+BEGIN_SRC ipython
def objective(x):
    I, e = quad(integrand, -x, x)
    return 0.95 - I

from scipy.optimize import fsolve
fsolve(objective, 2)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[50]:
# text/plain
: array([ 1.95996398])
:END:

The guideline of \pm 2 is an approximation of this result.

To find the mean, we evaluate the integral as following:

#+BEGIN_SRC ipython
def mean_integrand(x):
    return x * integrand(x)
quad(mean_integrand, -np.inf, np.inf)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[51]:
# text/plain
: (0.0, 0.0)
:END:

Clearly the integral (first value) is zero, as defined. Similarly this integral shows the variance.

#+BEGIN_SRC ipython
def var_integrand(x):
    return x**2 * integrand(x)

quad(var_integrand, -np.inf, np.inf)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[96]:
# text/plain
: (1.000000000000001, 5.274099954078797e-09)
:END:

And the variance is also 1, as defined.
* ASSIGNED exam2-4
  CLOSED: [2018-10-24 Wed 06:50]
  :PROPERTIES:
  :LABEL:    exam2-4
  :POINTS:   2
  :TYPE:     exam-2
  :RUBRIC:   default
  :RUBRIC_CATEGORIES: technical, presentation
  :RUBRIC_WEIGHTS: 0.8, 0.2
  :DUEDATE:  2018-10-24 10:20:00
  :GRADER:   John Kitchin
  :END:

*This is an exam problem. It is open note, and you may consult the internet. By turning in this problem, you agree that the work is your own, and you did not work with anyone to complete it. Anything else is considered cheating. If you see students working together on this problem, it is cheating and you should report it.*

The volume of a cylindrical can is $V = (\pi/4) D^2 L$. The cost of the top/bottom of the can is \$0.025 / cm^{2}, and the cost of the sides is \$0.043 / cm^{2}. If we require a volume of 355 cm^{3}, what is the optimal length and diameter to minimize the cost of the can?

Hint: $L = 4 V / \pi / D^2$. Then, you can formulate the total cost as a function of only $D$.

Show that your solution is a minimum, and compute the cost of the can.

#+BEGIN_SRC ipython

#+END_SRC


** solution                                                        :solution:

The cost of the top and bottom is $ct * \pi (D/2)^2 * 2$. The side cost is $cs * L * pi * D$.

We just setup a cost function, and plot it to get an initial guess for the solution.

#+BEGIN_SRC ipython
import numpy as np
from scipy.optimize import minimize

V = 355
ct = 0.025  # Cost of the top $/cm**2
cs = 0.043  # Cost of the side $/cm**2

def cost(D):
    radius = D / 2
    top_area = np.pi * radius**2
    top_bottom_cost = 2 * ct * top_area
    L = 4 * V / np.pi / D**2 # solved from the volume
    side_cost = cs * L * np.pi * D
    return top_bottom_cost + side_cost

D = np.linspace(1, 15)
c = cost(D)

%matplotlib inline
import matplotlib.pyplot as plt
plt.plot(D, c)
plt.xlabel('Diameter')
plt.ylabel('Cost')
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[52]:




# image/png
[[file:obipy-resources/73232f0e737f26c048822a8e09245932-65837BYZ.png]]
:END:

You can see there is a minimum near a diameter of 10 cm. Now we just minimize the cost function.

#+BEGIN_SRC ipython
sol = minimize(cost, 10)
print(sol)
D, = sol.x
L = 4 * V / np.pi / D**2
print(f'The optimal diameter is {D:1.2f} cm. The optimal length is {L:1.2f} cm. The cost is ${sol.fun:1.2f}.')
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[9]:
# output
:       fun: 9.960758701630086
:  hess_inv: array([[ 4.23703911]])
:       jac: array([ -1.19209290e-07])
:   message: 'Optimization terminated successfully.'
:      nfev: 18
:       nit: 5
:      njev: 6
:    status: 0
:   success: True
:         x: array([ 9.19508297])
: The optimal diameter is 9.20 cm. The optimal length is 5.35 cm. The cost is $9.96.
:
:END:

* TODO constrained optimization





p11 in Kreysig pg 943,

#+BEGIN_SRC ipython
def objective(x):
    x1, x2 = x
    return -10 * x1 + 2 * x2

def c1(x):
    x1, x2 = x
    return x1

def c2(x):
    x1, x2 = x
    return x2

def c3(x):
    x1, x2 = x
    return -x1 + x2 + 1

def c4(x):
    x1, x2 = x
    return 6 - x1 - x2

def c5(x):
    x1, x2 = x
    return 5 - x2

constraints = [{'type': 'ineq', 'fun': f} for f in [c1, c2, c3, c4, c5]]

minimize(objective, [1, 1], constraints=constraints)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[73]:
# text/plain
:      fun: -29.999999999998202
:      jac: array([-10.,   2.])
:  message: 'Optimization terminated successfully.'
:     nfev: 8
:      nit: 2
:     njev: 2
:   status: 0
:  success: True
:        x: array([ 3.5,  2.5])
:END:
* ASSIGNED Universal electric
  CLOSED: [2018-11-04 Sun 17:58]
  :PROPERTIES:
  :LABEL:    universal-electric
  :POINTS:   2
  :TYPE:     homework
  :RUBRIC:   default
  :RUBRIC_CATEGORIES: technical, presentation
  :RUBRIC_WEIGHTS: 0.8, 0.2
  :DUEDATE:  2018-11-08 23:59:59
  :GRADER:   Noriyuki Yoshio
  :END:

Universal Electric, Inc manufactures and sells two types of lamps: L1 and L2. They make a profit of \$150 on L1 and \$100 on L2. There are two workers that can make the lamps, W1 and W2. W1 works for 100 hours a month, and W2 works for 80 hours a month.

W1 assembles L1 in 20 minutes, and L2 in 30 minutes. W2 paints L1 in 20 min and L2 in 10 minutes. Assuming that all lamps that are made can be sold, how many of each kind of lamp should the workers make to maximize the profit, and how much profit will be made?

#+BEGIN_SRC ipython

#+END_SRC

** solution                                                        :solution:

There are two variables we need to solve for, L1 and L2, which are the number of each type of lamp we want to solve. The total profit is just the sum of the profit for each one times the profit of that lamp.

We have two constraints to consider. One is the total time that worker 1 works must be less than or equal to 100 hours/month, and the total time for worker two is 80 hours/month. We compute these times based on the time it takes to process each kind of lamp.

Here is the solution:

   #+BEGIN_SRC ipython
from scipy.optimize import minimize

def profit(X):
    L1, L2 = X
    return -(L1 * 150 + L2 * 100)

def c1(X):
    'W1 100 hours/month'
    L1, L2 = X
    return 100 - (L1 * 20 / 60 + L2 * 30 / 60)

def c2(X):
    'W2 80 hours / month'
    L1, L2 = X
    return 80 - (L1 * 20 / 60 + L2 * 10 / 60)

sol = minimize(profit, (10, 10),
               constraints=[{'type': 'ineq', 'fun': c1},
                            {'type': 'ineq', 'fun': c2}])
sol
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[1]:
# text/plain
:      fun: -37500.00000432619
:      jac: array([-150., -100.])
:  message: 'Optimization terminated successfully.'
:     nfev: 17
:      nit: 4
:     njev: 4
:   status: 0
:  success: True
:        x: array([ 210.00000003,   60.        ])
:END:

#+BEGIN_SRC ipython
print(f'We make ${-sol.fun:1.2f}/month of profit by making {int(sol.x[0])} L1 lamps, and {int(sol.x[1])} L2 lamps.')
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[4]:
# output
: We make $37500.00/month of profit by making 210 L1 lamps, and 60 L2 lamps.
:
:END:

We should check that the constraints are met. This means the constraint functions are greater than or equal to zero (within a tolerance).

#+BEGIN_SRC ipython
c1(sol.x), c2(sol.x)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[5]:
# text/plain
: (-1.0894893875956768e-08, -9.357535191156785e-09)
:END:

You can see the constraints in each case are practically zero, even though they are slightly negative. That means the workers are fully scheduled and working the maximum number of hours each.

* ASSIGNED United metal
  CLOSED: [2018-11-06 Tue 21:15]
  :PROPERTIES:
  :LABEL:    quiz-3
  :POINTS:   2
  :TYPE:     quiz
  :RUBRIC:   default
  :RUBRIC_CATEGORIES: technical, presentation
  :RUBRIC_WEIGHTS: 0.8, 0.2
  :DUEDATE:  2018-11-07 10:20:00
  :GRADER:   Noriyuki Yoshio
  :END:

United metal produces alloys B1 and B2. B1 contains 50% copper and 50% zinc. B2 contains 75% copper and 25% zinc. The net profit on B1 is \$120/ton and on B2 is \$100/ton. The company has 45 tons of copper available per day, and 30 tons of zinc available per day. How much of each alloy should they make to maximize their profit? What is the profit?

** solution                                                        :solution:
#+BEGIN_SRC ipython
from scipy.optimize import minimize

def profit(X):
    B1, B2 = X
    return -(120 * B1 + 100 * B2)

def c1(X):
    B1, B2 = X
    return 45 - 0.5 * B1 - 0.75 * B2

def c2(X):
    B1, B2 = X
    return 30 - 0.5 * B1 - 0.25 * B2

minimize(profit, (10, 10),
         constraints=[{'type': 'ineq', 'fun': c1},
                      {'type': 'ineq', 'fun': c2}])
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[9]:
# text/plain
:      fun: -8400.000000280243
:      jac: array([-120., -100.])
:  message: 'Optimization terminated successfully.'
:     nfev: 12
:      nit: 2
:     njev: 2
:   status: 0
:  success: True
:        x: array([ 45.,  30.])
:END:

You should make 45 tones of B1 and 30 tones of B2. You can see from the solution above that the profit is $8400 per day.
* ASSIGNED Linear BVP
  CLOSED: [2018-11-12 Mon 20:40]
  :PROPERTIES:
  :LABEL:    linear-bvp
  :POINTS:   3
  :TYPE:     homework
  :RUBRIC:   default
  :RUBRIC_CATEGORIES: technical, presentation
  :RUBRIC_WEIGHTS: 0.8, 0.2
  :DUEDATE:  2018-11-20 23:59:59
  :GRADER:   Mingjie Liu
  :END:

This boundary value problem is linear.

$y'' + y = 0$

With boundary conditions $y(0) = 0$ and $y(\pi/2) = 2$

First, derive the equations that approximate this equation using finite differences. You should write out the equations in a form that allow you to construct a set of linear equations, e.g. $\mathbf{A} \mathbf{y} = \mathbf{b}$.

#+BEGIN_SRC ipython

#+END_SRC

Next, write code to construct $\mathbf{A}$ and $\mathbf{b}$, and solve for $\mathbf{y}$.

#+BEGIN_SRC ipython

#+END_SRC

Show some evidence that your solution is reasonable.

#+BEGIN_SRC ipython

#+END_SRC

Finally, there is a known analytical solution to this equation: $y = 2 \sin x$. Compare your answer to the known solution.

#+BEGIN_SRC ipython

#+END_SRC


** solution                                                        :solution:

The key to this problem is to derive the finite difference formulas:

$y_{j+1} - 2 y_j + y_{j-1} + h^2 y_j= 0$

$y_{j-1} + (h^2 - 2) y_j + y_{j+1} = 0$

and then to construct the matrix. These matrices are called Toeplitz matrices, and there is an easy way to construct them in numpy.

#+BEGIN_SRC ipython
import numpy as np
N = 50
x, h = np.linspace(0, np.pi/2, N, retstep=True)

from scipy.linalg import toeplitz
r = np.zeros(N - 2)
r[0] = h**2  - 2
r[1] = 1

c = np.zeros(N - 2)
c[0] = h**2 - 2
c[1] = 1
A = toeplitz(c, r)

# Here is an alternative approach.
# A = np.eye(N - 2) * (h**2 * _lambda - 2)
# U = np.diag(np.ones(N - 3), 1)
# L = np.diag(np.ones(N - 3), -1)

# A = A + U + L
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[4]:
:END:

Then you just build up the right hand side of the equation to finally yield:

$\mathbf{A} \mathbf{y} = \mathbf{b}$

and solve for $\mathbf{y}$ with ~np.linalg.solve~. Don't forget to add the boundary conditions back on to the solution. We know the analytical solution to this BVP, it is $y(x) = 2 \sin(x)$, so we plot it for comparison.

#+BEGIN_SRC ipython
b = np.zeros(N - 2)
b[-1] = -2
y_inner = np.linalg.solve(A, b)

# add the boundary values back on.
y = np.concatenate([[0], y_inner, [2]])

%matplotlib inline
import matplotlib.pyplot as plt
plt.plot(x, y)
plt.plot(x, 2 * np.sin(x), 'r--') # analytical solution
plt.xlabel('x')
plt.ylabel('y')
plt.legend(['numeric solution', 'analytical solution'])
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[11]:




# image/png
[[file:obipy-resources/73232f0e737f26c048822a8e09245932-22007_tM.png]]
:END:

These two solutions are visually indistinguishable.

* ASSIGNED A constrained minimization
  CLOSED: [2018-11-18 Sun 18:02]
  :PROPERTIES:
  :LABEL:    quiz-4
  :POINTS:   3
  :TYPE:     quiz
  :RUBRIC:   default
  :RUBRIC_CATEGORIES: technical, presentation
  :RUBRIC_WEIGHTS: 0.8, 0.2
  :DUEDATE:  2018-11-19 10:20:00
  :GRADER:   John Kitchin
  :END:

*This is a quiz. You may not talk during the quiz except to ask an instructor a question. You are not allowed to look at other people's work. By turning this in, you agree that you did not cheat and that this work is only your own. You may not modify your quiz after the due time without permission.*

Given the equation $f(y) = y_{1}^2 - 4 y_{1}  + \frac{3}{2} y_{2}^2 - 7 y_{2} + y_{1} y_{2} + 8 - \ln(y_{1}) - \ln(y_{2})$ with $y_{1} > 0$ and $y_{2} > 0$, perform the following analyses:

Generate a contour plot for $f(y)$ that shows where the minimum is. State in words where the approximate minimum is.

#+BEGIN_SRC ipython

#+END_SRC

Find the minimum (any way you want).

#+BEGIN_SRC ipython

#+END_SRC

Show quantitative evidence that your solution is a minimum.

#+BEGIN_SRC ipython

#+END_SRC


** solution                                                        :solution:

Here is a way to make a contour plot.

#+BEGIN_SRC ipython
import numpy as np

def f(y):
    y1, y2 = y
    return y1**2 - 4 * y1 + 3 / 2 * y2**2 - 7 * \
        y2 + y1 * y2 + 8 - np.log(y1) - np.log(y2)


y1 = np.linspace(0.01, 4)
y2 = np.linspace(0.01, 4)
Y1, Y2 = np.meshgrid(y1, y2)

F= f(np.array([Y1, Y2]))

%matplotlib inline
import matplotlib.pyplot as plt
plt.contour(Y1, Y2, F)
plt.colorbar()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[23]:




# image/png
[[file:obipy-resources/73232f0e737f26c048822a8e09245932-25250zlI.png]]
:END:

Based on this, we can see that there is a minimum near (1.5, 2.0).

#+BEGIN_SRC ipython
from scipy.optimize import minimize

sol = minimize(f, [1.5, 2.0])
sol
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[25]:
# text/plain
:       fun: -1.8742240831673438
:  hess_inv: array([[ 0.45608477, -0.13781933],
:        [-0.13781933,  0.35075638]])
:       jac: array([ -9.84966755e-06,  -3.62098217e-06])
:   message: 'Optimization terminated successfully.'
:      nfev: 24
:       nit: 3
:      njev: 6
:    status: 0
:   success: True
:         x: array([ 1.34754467,  2.04699125])
:END:

To prove this is a minimum, we note that the sol.jac (jacobian) is close to zero, so that means we are at a stationary point. To prove we are at a minimum though, we must show the hessian is positive definite. We can do that by showing the inverse of the inverse hessian (which is the hessian) has all positive eigenvalues.

#+BEGIN_SRC ipython
np.linalg.eigvals(np.linalg.inv(sol.hess_inv))
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[28]:
# text/plain
: array([ 1.81501599,  3.90805409])
:END:

This proves we are at a minimum (provided the approximate inverse hessian is accurate). A better approach is to use a tool like autograd to compute an exact hessian.

Why does positive definite imply a minumum? Qualitatively it means the curvature at this point is positive (concave up) in all directions.

Quantitatively, we can express a Taylor's series expansion around a point as:

$f(\mathbf{x}) = f(\mathbf{x0}) + f'(\mathbf{x} - \mathbf{x0}) + 0.5 \mathbf{x}^T H(\mathbf{x}) \mathbf{x} + ...$

The first term is the value at the minumum. The second term should be zero since we are at a stationary point. If H is positive definite, then $\mathbf{x}^T H(\mathbf{x}) \mathbf{x}$ will be positive, which means for /any/ $\mathbf{x}$ the function increases, so you are therefore at a minimum.
* ASSIGNED Using the Hessian in optimization
  CLOSED: [2018-11-27 Tue 21:07]
  :PROPERTIES:
  :LABEL:    quiz-5
  :POINTS:   3
  :TYPE:     quiz
  :RUBRIC:   default
  :RUBRIC_CATEGORIES: technical, presentation
  :RUBRIC_WEIGHTS: 0.8, 0.2
  :DUEDATE:  2018-11-28 10:20:00
  :GRADER:   John Kitchin
  :END:

*This is a quiz. You must be present in class to get credit for it. All your work must be your own, and turning this in means you agree that you worked alone on this assignment.*

Newton's method is an iterative method based on finding roots using information about the derivative. There is an improvement if we use the Hessian shown below:

$x_{n+1} = x_n - \mathbf{H(x_n)}^{-1} \mathbf{\nabla f(x_n)}$

where $\mathbf{H(x_n)}$ is the Hessian matrix, and $\nabla f(x_n)$ is the gradient of $f$ evaluated at $x_n$, which may be a vector. $f$ is a scalar function. This algorithm is still iterative, and starts from an initial guess.

Use this information with autograd to find a minimum of the rosenbrock function starting at the point (5.0, 5.0). Verify you have found a minimum.

#+BEGIN_SRC ipython
def rosenbrock(X):
    x, y = X
    return (1 - x)**2 + 100 * (y - x**2)**2
#+END_SRC



** solution                                                        :solution:

The solution to this problem is to use autograd to get functions fro the gradient and hessian, and then implement the formula provided inside a loop. Here I do that, and print the intermediate steps. You can see by the third step the output is almost constant, and by the 5th step it is constant, indicating no further changes are occurring.

#+BEGIN_SRC ipython
x = np.array([5.0, 5.0])

def rosenbrock(X):
    x, y = X
    return (1 - x)**2 + 100 * (y - x**2)**2

from autograd import grad, hessian
df = grad(rosenbrock)
dH = hessian(rosenbrock)

for i in range(6):
    x = x - np.linalg.inv(dH(x)) @ df(x)
    print(x)
x
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[16]:
# output
[  4.99900025  24.9900025 ]
[  1.00079924 -14.98401219]
[ 1.00079899  1.00159862]
[ 1.          0.99999936]
[ 1.  1.]
[ 1.  1.]

# text/plain
: array([ 1.,  1.])
:END:

Based on the output above, it appears the minimum is at $\mathbf{X}=(1, 1)$. This is the same as we saw before in lecture. We can confirm it is a stationary point be looking at the gradients.  We can see the first derivatives are zero, which means we have found a stationary point.

#+BEGIN_SRC ipython
print(df(x))
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[17]:
# output
: [ 0.  0.]
:
:END:

Finally to confirm it is a minimum we have to show the Hessian is positive definite, by making sure the eigenvalues are all positive. Here we can see the eigenvalues of the Hessian are all positive, so we also know this is a minimum.

#+BEGIN_SRC ipython
print(np.linalg.eigvals(dH(x)))
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[19]:
# output
: [  1.00160064e+03   3.99360767e-01]
:
:END:
* ASSIGNED Fit a NN to some data of your choice
  CLOSED: [2018-12-02 Sun 19:47]
  :PROPERTIES:
  :LABEL:    nn-pvap
  :POINTS:   3
  :TYPE:     homework
  :RUBRIC:   default
  :RUBRIC_CATEGORIES: technical, presentation
  :RUBRIC_WEIGHTS: 0.8, 0.2
  :DUEDATE:  2018-12-07 23:59:59
  :GRADER:   Noriyuki Yoshio
  :END:

In this paper: Experimental vapor pressure data and a vapor pressure equation for trifluoroiodomethane (CF3I), https://www.sciencedirect.com/science/article/pii/0378381296030051?via%3Dihub, the following data is provided for the vapor pressure as a function of temperature.

#+BEGIN_SRC ipython
import numpy as np

T = np.array([ 243.15,  245.15,  247.15,  249.15,  251.15,  253.15,  255.15,
         257.15,  259.15,  261.15,  263.15,  265.15,  267.15,  269.15,
         271.15,  273.15,  275.15,  277.15,  279.15,  281.15,  283.15,
         285.15,  287.15,  289.15,  291.15,  293.15,  295.15,  297.15,
         299.15,  301.15,  303.15,  305.15,  307.15,  309.15,  311.15,
         313.15,  315.15,  317.15,  319.15,  321.15,  323.15,  325.15,
         327.15,  329.15,  331.15,  333.15,  335.15,  337.15,  339.15,
         341.15,  343.15,  345.15,  347.15,  349.15,  353.15,  358.15,
         363.15,  368.15,  373.15,  378.15,  383.15,  388.15,  393.15])

Pvap = np.array([ 0.0717,  0.0782,  0.0852,  0.0928,  0.1007,  0.1092,  0.1181,
         0.1278,  0.138 ,  0.1488,  0.1603,  0.1722,  0.1851,  0.1986,
         0.2128,  0.228 ,  0.2439,  0.2602,  0.2778,  0.2963,  0.3156,
         0.3359,  0.3572,  0.3795,  0.4027,  0.4269,  0.4522,  0.4785,
         0.5062,  0.5349,  0.565 ,  0.5961,  0.6287,  0.6624,  0.6975,
         0.734 ,  0.7718,  0.8111,  0.8517,  0.8939,  0.9376,  0.9826,
         1.0295,  1.078 ,  1.1282,  1.1802,  1.2337,  1.2891,  1.3461,
         1.4045,  1.4656,  1.5283,  1.5929,  1.6593,  1.7986,  1.9849,
         2.1854,  2.4   ,  2.6303,  2.8777,  3.143 ,  3.4279,  3.7363])
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[100]:
:END:

Use the material from lecture 21 to develop a simple neural network model for this data. Describe what work you did to avoid overfitting the data, and your analysis about whether the neural network is useful for future predictions of the vapor pressure. Discuss the differences in your model with the one in the paper.

** solution                                                        :solution:

This is kind of a tricky problem. The setup is easy, but whether it converges or not depends on the initialization, which is somewhat random. Here I used a more explicit form of the neural network, but you could also have used the matrix form. The activation function choice is not important, as long as you get a good fit. The optimization method is also not important; least_squares, curve_fit, nlinit, etc. probably all work.

#+BEGIN_SRC ipython
from scipy.optimize import least_squares

def model(x, *pars):
    b1, w10, w00, b00, w11, w01, b01, w12, w02, b02 = pars
    pred = (b1 + w10 * np.tanh(w00 * x + b00)
               + w11 * np.tanh(w01 * x + b01)
               + w12 * np.tanh(w02 * x + b02))
    return pred


def resid(pars):
    return Pvap - model(T, *pars)

pars = least_squares(resid, x0=np.random.randn(10) * 0.1)
print(pars.message, pars.cost, pars.grad)

%matplotlib inline
import matplotlib.pyplot as plt
plt.plot(T, Pvap, 'b.', T, model(T, *pars.x), 'r-')

print(pars.x)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[108]:
# output
`ftol` termination condition is satisfied. 0.00151043162184 [ -3.47571203e-07   3.47571210e-07   0.00000000e+00   0.00000000e+00
   3.47571205e-07   0.00000000e+00   0.00000000e+00  -2.86871892e-07
   2.04556731e-04   6.09782803e-07]
[-1.40871587 -9.2353123  -0.16133809 -0.15824029  2.01550589 -0.10264338
  0.0391223  -5.94314714 -0.01130074  4.81118968]



# image/png
[[file:obipy-resources/73232f0e737f26c048822a8e09245932-2031_Iz.png]]
:END:

You should check that the optimizer converged. It is not crucial to print the parameters, but if you don't it is harder to reuse your model later. The model above had 10 parameters, and visually fits the data well. That suggests a smaller model might also work. Next we try one with 7 parameters (only 2 neurons). It is not essential that you follow this specific path, there are other ways you could assess if a simpler model is sufficient.

#+BEGIN_SRC ipython
def model(x, *pars):
    b1, w10, w00, b00, w11, w01, b01 = pars
    pred = (b1 + w10 * np.tanh(w00 * x + b00)
               + w11 * np.tanh(w01 * x + b01))
    return pred


def resid(pars):
    return Pvap - model(T, *pars)

pars = least_squares(resid, x0=np.random.randn(7) * 0.1)
print(pars.message, pars.cost, pars.grad)

%matplotlib inline
import matplotlib.pyplot as plt
plt.plot(T, Pvap, 'b.', T, model(T, *pars.x), 'r-')
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[109]:
# output
`ftol` termination condition is satisfied. 0.00151043162184 [ -1.63508859e-08   1.17687677e-08  -2.36111238e-05  -1.02763429e-07
   1.63508859e-08   0.00000000e+00   0.00000000e+00]

# text/plain
: [<matplotlib.lines.Line2D at 0x11846b630>,
:  <matplotlib.lines.Line2D at 0x11846b7b8>]



# image/png
[[file:obipy-resources/73232f0e737f26c048822a8e09245932-2031xSC.png]]
:END:

This model also has a good fit.

We can compare the results to the paper. Here I compare the residuals of the two models. Now you can see that even though the NN model looks ok, the paper in the model (which is a nonlinear power series type model) has much smaller errors than the NN. It is possible to improve the NN model, e.g. by using more neurons, other activation functions, different initializations, etc.

#+BEGIN_SRC ipython
def Pv(T):
    A1 = -7.19045
    A2 = 1.34829
    A3 = -1.58035
    A4 = -5.46680
    Tc = 395.05
    Pc = 3.8617
    tau = 1 - T / Tc
    lnPPc = (A1 * tau + A2 * tau**1.25 + A3 * tau**3 + A4*tau**7) * Tc / T
    Ppc = np.exp(lnPPc)
    return Ppc * Pc

plt.plot(T, Pv(T) - Pvap,  T, model(T, *pars.x) - Pvap)
plt.legend(['paper', 'NN'])
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[113]:




# image/png
[[file:obipy-resources/73232f0e737f26c048822a8e09245932-2031l7a.png]]
:END:

This pattern of residuals indicates inadequacy in the model because the residuals are not normally distributed. There are regions of systematic under and overshooting.

We can't really say the model in the paper is more interpretable, none of the terms have particular physical significance. There are fewer parameters, and they used scaling of the pressure and temperature as part of the model. We could also do that in the NN, and we might get better performance.

It was not necessary to do this, but here we explore this possibility. curve_fit hits a maximum function evaluation, but reaches a reasonably low error and fit.

#+BEGIN_SRC ipython
def model(x, *pars):
    b1, w10, w00, b00, w11, w01, b01 = pars
    pred = (b1 + w10 * np.tanh(w00 * x + b00)
               + w11 * np.tanh(w01 * x + b01))
    return pred

Tc = 395.05
Pc = 3.8617

lnPPC = np.log(Pvap / Pc)
Tr = T / Tc

def resid(pars):
    return lnPPC - model(Tr, *pars)

pars = least_squares(resid, x0=np.random.randn(7) * 0.1)
print(pars.message, pars.cost, pars.grad)

plt.plot(T, Pvap, 'b.', Tr * Tc, np.exp(model(Tr, *pars.x)) * Pc, 'r-')
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[128]:
# output
The maximum number of function evaluations is exceeded. 1.09024576943e-05 [  3.57175172e-04  -7.34434414e-05  -2.49633460e-03  -3.53614233e-03
  -3.33530876e-04  -6.32193843e-04  -9.23121787e-04]

# text/plain
: [<matplotlib.lines.Line2D at 0x118e3e5f8>,
:  <matplotlib.lines.Line2D at 0x118e3e630>]



# image/png
[[file:obipy-resources/73232f0e737f26c048822a8e09245932-2031yMV.png]]
:END:

More importantly, this shows that we have significantly reduced the errors especially at lower temperatures. A better optimizer might be able to find a lower error solution to further improve the high temperature errors.

#+BEGIN_SRC ipython
plt.plot(T, Pv(T) - Pvap,  T, np.exp(model(Tr, *pars.x)) * Pc - Pvap)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[130]:
# text/plain
: [<matplotlib.lines.Line2D at 0x118681908>,
:  <matplotlib.lines.Line2D at 0x118681f28>]



# image/png
[[file:obipy-resources/73232f0e737f26c048822a8e09245932-2031Mhh.png]]
:END:

These residuals are more normally distributed, except at the end where there is structure that indicates an issue with the model.
* ASSIGNED van Laar equation
  CLOSED: [2018-12-02 Sun 20:04]
  :PROPERTIES:
  :LABEL:    ag-gibbs-duhem
  :POINTS:   2
  :TYPE:     homework
  :RUBRIC:   default
  :RUBRIC_CATEGORIES: technical, presentation
  :RUBRIC_WEIGHTS: 0.8, 0.2
  :DUEDATE:  2018-12-07 23:59:59
  :GRADER:   Noriyuki Yoshio
  :END:

Review the expression for $\frac{G_{ex}}{RT}$ in the Van Laar equation at
https://en.wikipedia.org/wiki/Van_Laar_equation.

There are also equations for the two activity coefficients that are derived from that expression. According to the Gibbs-Duhem equation:

$0 = x_1 \frac{d \ln \gamma_1}{d n_1} + x_2 \frac{d \ln \gamma_2}{d n_1}$

Assuming we have a mixture of Acetone and water, use autograd to demonstrate that the Gibbs-Duhem equation is satisfied over the range of composition for $0 \le x_1 \le 1$.

You may find it helpful to note that $x_1 = \frac{n_1}{n_1 + n_2}$.

** solution                                                        :solution:

There are several ways to approach this problem. The most straightforward way is to define two functions for the activity coefficients with $n1$ as the argument. You have to specify the number of moles of $n2$ that are present. You can choose this number. Then, you just compute the desired derivatives, and show that they make the Gibbs-Duhem equation equal zero.

#+BEGIN_SRC ipython
import autograd.numpy as np
from autograd import grad
A12 = 2.1041
A21 = 1.5555

n2 = 1.0

def lng1(n1):
    x1 = n1 / (n1 + n2)
    x2 = 1 - x1
    return A12 * ((A21 * x2) / (A12 * x1 + A21 * x2))**2

def lng2(n1):
    x1 = n1 / (n1 + n2)
    x2 = 1 - x1
    return A21 * ((A12 * x1) / (A12 * x1 + A21 * x2))**2

dlng1 = grad(lng1)
dlng2 = grad(lng2)

N1 = np.linspace(0, 2)
X1 = N1 / (N1 + n2)
X2 = 1 - X1

GD = X1 * [dlng1(n1) for n1 in N1] + X2 * [dlng2(n1) for n1 in N1]
np.allclose(GD, np.zeros(GD.shape))
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[14]:
# text/plain
: True
:END:

The final statement shows that the Gibbs-Duhem equation evaluates to zero for all values of $n1$ from 0 to 2 moles.

* ASSIGNED Quiz 6 - uncertainty propagation in implicit functions
  CLOSED: [2018-12-04 Tue 19:52]
  :PROPERTIES:
  :LABEL:    quiz-6
  :POINTS:   2
  :TYPE:     quiz
  :RUBRIC:   default
  :RUBRIC_CATEGORIES: technical, presentation
  :RUBRIC_WEIGHTS: 0.8, 0.2
  :DUEDATE:  2018-12-05 10:20:00
  :GRADER:   John Kitchin
  :END:

The equation $y = e^{a y}$ is implicit in $y$. Suppose we know that $a = 0.2 \pm 0.02$ ($\sigma_a = 0.02$). First, solve for the value of $y$  with a method of your choice.

#+BEGIN_SRC ipython

#+END_SRC

Now the question is what is the uncertainty in $y$ since we know there is some uncertainty in $a$? A good approximation for the uncertainty in $y$ is $\sigma_y \approx \frac{dy}{da} * \sigma_a$.  Use this information to estimate the uncertainty ($\sigma_y$) in the solution you obtained.

#+BEGIN_SRC ipython

#+END_SRC

Describe an engineering application where this could be useful.

#+BEGIN_SRC ipython

#+END_SRC


** solution                                                        :solution:

#+BEGIN_SRC ipython
import autograd.numpy as np
from autograd import grad

sigma_a = 0.02
def f(y, alpha=0.2):
    return y - np.exp(alpha * y)

from scipy.optimize import fsolve
Y, = fsolve(f, 1.2)

print(f'y = {Y}')
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[14]:
# output
y = 1.2958555090953687

:END:

The key point in the uncertainty analysis is we need to compute dy/da, but we have an implicit function for f(y, a) = 0. So, we have to use the implicit derivative formula: dy/da = -df/da / df/dy.

#+BEGIN_SRC ipython
dfdy = grad(f, 0)
dfda = grad(f, 1)

dyda = -dfda(Y, 0.2) / dfdy(Y, 0.2)

sigma_y = dyda * sigma_a
print(f'The uncertainty in y is \pm {sigma_y:1.3f}')
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[18]:
# output
The uncertainty in y is \pm 0.045

:END:

There is another root you may have found.

#+BEGIN_SRC ipython
def f(y, alpha=0.2):
    return y - np.exp(alpha * y)

from scipy.optimize import fsolve
Y, = fsolve(f, 12)

print(f'y = {Y}')
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[20]:
# output
y = 12.71320678886763

:END:

We use the same formula to estimate the uncertainty here.

#+BEGIN_SRC ipython
dfdy = grad(f, 0)
dfda = grad(f, 1)

dyda = -dfda(Y, 0.2) / dfdy(Y, 0.2)

sigma_y = dyda * sigma_a
print(f'The uncertainty in y is \pm {sigma_y:1.3f}')
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[21]:
# output
The uncertainty in y is \pm -2.095

:END:

It is a little confusing to see a negative number there, but in a \pm sense it doesn't matter. This happens because the real formula should be: $\sigma_y^2 \approx \frac{dy}{da}^2 * \sigma_a^2$, so $sigma_y$ should always be positive.

There are many reasonable answers for applications, but to get full credit it should have been specific, about uncertainty, and involving implicit functions. Vague, nonspecific answers did not get full credit.




* ASSIGNED exam3-1 uncertainty               :autograd:uncertainty:p1:2:nori:
  CLOSED: [2018-12-10 Mon 11:54]
  :PROPERTIES:
  :LABEL:    exam3-1
  :POINTS:   2
  :TYPE:     exam-3
  :RUBRIC:   default
  :RUBRIC_CATEGORIES: technical, presentation
  :RUBRIC_WEIGHTS: 0.8, 0.2
  :DUEDATE:  2018-12-10 16:00:00
  :GRADER:   Noriyuki Yoshio
  :END:

*This is an exam. You must be present in the exam room to get credit for this problem unless you have prior permission from the instructor. You may not talk during the exam except to ask an instructor a question. By turning this in, you agree that this work is your own, and you did not get unauthorized help to complete it or provide unauthorized help to anyone else. You may not modify your exam answer after the due time without permission.*

The time required to reach a particular conversion $X$ in a reactor is given by this integral equation:

$t = \int_0^X \frac{1}{k C_{A0} (1 - X)^2} dX$

In this problem, $k = 1e-3$ L/mol/min, and $C_{A0} = 1$ mol/L.

We aim to find the uncertainty in the amount of time required to reach a conversion of 0.9. The uncertainty is estimated by:

$\sigma_t = \sqrt{\frac{\partial t}{\partial k}^2 \sigma_k^2 + \frac{\partial t}{\partial C_{A0}}^2 \sigma_{C_{A0}}^2 }$

with $\sigma_k = 1e-4$ and $\sigma_{C_{A0}} = 0.01$.

To evaluate those derivatives, we need a differentiable integrator. You can use this implementation of the trapezoid rule for that. You cannot use the quad function.

#+BEGIN_SRC ipython
import autograd.numpy as np

def trapz(y, x):
    d = np.diff(x)
    return np.sum((y[0:-1] + y[1:]) * d / 2)
#+END_SRC

First, use the equation above and the provided trapz function to find the time required to reach 90% conversion for this reactor.

#+BEGIN_SRC ipython

#+END_SRC

Next, use the formula for $\sigma_t$ to estimate the uncertainty in this time.

#+BEGIN_SRC ipython

#+END_SRC


** solution                                               :solution:

This problem requires you to compute the derivatives of the integral function. The first step for that is to define a function of (k, Ca0) that returns the time.

#+BEGIN_SRC ipython
import autograd.numpy as np
k = 1e-3
sigma_k = 1e-4

Ca0 = 1.0
sigma_Ca0 = 0.01


X = np.linspace(0.0, 0.9, 5000)

def trapz(y, x):
    d = np.diff(x)
    return np.sum((y[0:-1] + y[1:]) * d / 2)

def t(k, Ca0):
    integrand = 1./(k*Ca0)*(1./(1-X)**2)
    return trapz(integrand, X)

print(t(k, Ca0))
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[132]:
# output
9000.00539675

:END:

Next, we can use autograd to get the required derivatives and estimate $\sigma_t$.

#+BEGIN_SRC ipython
dtdk = grad(t, 0)
dtdC = grad(t, 1)

sigma_t = np.sqrt(dtdk(k, Ca0)**2 * sigma_k**2 + dtdC(k, Ca0)**2 * sigma_Ca0**2)
sigma_t
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[123]:
# text/plain
: 904.48881132260317
:END:

The solution is finally it will be 9000 minutes, \pm 904 minutes.


* ASSIGNED exam3-2 eigenvalue                               :LA:p2:3:mingjie:
  CLOSED: [2018-12-10 Mon 11:45]
  :PROPERTIES:
  :LABEL:    exam3-2
  :POINTS:   3
  :TYPE:     exam-3
  :RUBRIC:   default
  :RUBRIC_CATEGORIES: technical, presentation
  :RUBRIC_WEIGHTS: 0.8, 0.2
  :DUEDATE:  2018-12-10 16:00:00
  :GRADER:   Mingjie Liu
  :END:

*This is an exam. You must be present in the exam room to get credit for this problem unless you have prior permission from the instructor. You may not talk during the exam except to ask an instructor a question. By turning this in, you agree that this work is your own, and you did not get unauthorized help to complete it or provide unauthorized help to anyone else. You may not modify your exam answer after the due time without permission.*

We have mostly focused on numerical solutions to ODEs. Sometimes, it is possible to leverage Python to obtain analytical solutions though. This problem will focus on a way to do that. We will focus on these equations:

$y_1'(t) = -0.02 y_1 + 0.02 y_2$

$y_2'(t) = 0.02 y_1 - 0.02 y_2$

with the initial conditions that $y_1(0) = 0$ and $y_2(0) = 150$.

We can rewrite the equations in matrix form:

$\mathbf{y'} = \mathbf{A} \mathbf{y}$

Here we have $\mathbf{y'} = \left[\begin{array}{c} y_1'(t) \\ y_2'(t)\end{array}\right]$ and $\mathbf{y} = \left[\begin{array}{c} y_1(t) \\ y_2(t)\end{array}\right]$. $\mathbf{A}$ is the array of coefficients.

This is a set of constant coefficient, coupled ODEs. We can try a solution of the form:

$\mathbf{y} = \mathbf{x} e^{\lambda t}$, where we have an unknown vector $\mathbf{x}$ and $\lambda$, and we seek to find values for these that solve the equations.

If you plug this in to the equations then we find:

$\mathbf{y'} = \lambda \mathbf{x} e^{\lambda t} = \mathbf{A} \mathbf{x} e^{\lambda t}$

Or, with some minor rearrangement:

$\mathbf{A} \mathbf{x} = \lambda \mathbf{x}$

This is an eigenvalue problem, and the solutions to it are the pairs of eigenvalues ($\lambda$) and corresponding eigenvectors ($\mathbf{x}$).

Find the eigenvalues and eigenvectors of this system of equations:

#+BEGIN_SRC ipython

#+END_SRC

The solution to the system of ODEs is then a linear combination defined by:

$\mathbf{y(t)} = c_1 \mathbf{x_1} e^{\lambda_1 t} + c_2 \mathbf{x_2} e^{\lambda_2 t}$

where $c_i$ are arbitrary constants, and $\mathbf{x_i}$ is the i^{th} eigenvector that corresponds to the i^{th} eigenvalue $\lambda_i$. To find the values of $c_i$ we must use the initial conditions. At $t=0$ we can express this in the form:

\begin{equation}
\left[\begin{array}{c}y_1(0) \\ y_2(0)\end{array}\right]=
[\begin{array}{cc}\mathbf{x_1} & \mathbf{x_2}\end{array}]
\left[\begin{array}{c}c_1\\c_2\end{array}\right]
\end{equation}

where $[\begin{array}{cc}\mathbf{x_1} & \mathbf{x_2}\end{array}]$ is an array with $\mathbf{x_i}$ in the i^{th} column, in other words it is an array of the eigenvectors in column form.

Solve this linear equation for the unknown coefficients $\mathbf{c}$.

#+BEGIN_SRC ipython

#+END_SRC

Finally, combine all of this information to get the complete solution

$\mathbf{y(t)} = c_1 \mathbf{x_1} e^{\lambda_1 t} + c_2 \mathbf{x_2} e^{\lambda_2 t}$. There is not a simple matrix algebra way to do this, so I suggest you do it as:

$y1(t) = c_1 \mathbf{x_1}[0] e^{\lambda_1 t} + c_2 \mathbf{x_2}[0] e^{\lambda_2 t}$

and

$y2(t) = c_1 \mathbf{x_1}[1] e^{\lambda_1 t} + c_2 \mathbf{x_2}[1] e^{\lambda_2 t}$


and plot the solution for $y_1(t)$ and $y_2(t)$ from t=0 to t=100.

#+BEGIN_SRC ipython

#+END_SRC

** solution                                                        :solution:

First we find the eigenvalues and eigenvectors.

#+BEGIN_SRC ipython
import numpy as np

A = np.array([[-0.02, 0.02],
              [0.02, -0.02]])

evals, evecs = np.linalg.eig(A)

print(evals, evecs)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[1]:
# output
[ 0.   -0.04] [[ 0.70710678 -0.70710678]
 [ 0.70710678  0.70710678]]

:END:

Next, solve for the unknown coefficients.

#+BEGIN_SRC ipython
c = np.linalg.solve(evecs, [0, 150])
c
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[2]:
# text/plain
: array([ 106.06601718,  106.06601718])
:END:

Finally we combine them.
#+BEGIN_SRC ipython
t = np.linspace(0, 100)

x1 = evecs[:, 0]
x2 = evecs[:, 1]

y1 = c[0] * x1[0] * np.exp(evals[0] * t) + c[1] * x2[0] * np.exp(evals[1] * t)
y2 = c[1] * x1[1] * np.exp(evals[0] * t) + c[1] * x2[1] * np.exp(evals[1] * t)

%matplotlib inline
import matplotlib.pyplot as plt
plt.plot(t, y1, t, y2)
plt.legend(['y1', 'y2'])
plt.xlabel('t')
plt.ylabel('y')
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[4]:




# image/png
[[file:obipy-resources/73232f0e737f26c048822a8e09245932-50547PVY.png]]
:END:


Here is the numpy way of writing this solution. It is more advanced syntax than we have used in class and involves combinations of matrix algebra, elementwise operations and broadcasting. You did not have to do this.

#+BEGIN_SRC ipython
y = c[None, :] * evecs @ np.array([np.exp(evals[0] * t),
                                   np.exp(evals[1] * t)])
# transpose y so it is in columns.
plt.plot(t, y.T)
plt.legend(['y1', 'y2'])
plt.xlabel('t')
plt.ylabel('y')
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[5]:




# image/png
[[file:obipy-resources/73232f0e737f26c048822a8e09245932-50547cfe.png]]
:END:




* ASSIGNED exam3-3 nla - continuation                :autograd:ode:p3:3:john:
  CLOSED: [2018-12-10 Mon 11:46]
  :PROPERTIES:
  :LABEL:    exam3-3
  :POINTS:   3
  :TYPE:     exam-3
  :RUBRIC:   default
  :RUBRIC_CATEGORIES: technical, presentation
  :RUBRIC_WEIGHTS: 0.8, 0.2
  :DUEDATE:  2018-12-10 23:59:59
  :GRADER:   John Kitchin
  :END:

*This is an exam. You must be present in the exam room to get credit for this problem unless you have prior permission from the instructor. You may not talk during the exam except to ask an instructor a question. By turning this in, you agree that this work is your own, and you did not get unauthorized help to complete it or provide unauthorized help to anyone else. You may not modify your exam answer after the due time without permission.*

# http://kitchingroup.cheme.cmu.edu/blog/2013/02/22/Method-of-continuity-for-nonlinear-equation-solving/

A common problem in solving nonlinear problems is /how to make the initial guess/?

Let's consider finding the solution to the following nonlinear equations:

$2 + x + y - x^2 + 8 x y + y^3 = 0$

$1 + 2x - 3y + x^2 + xy - y e^x = 0$

The strategy we work on here is to reformulate these equations with a new variable $\lambda$

$2 + x + y + \lambda(- x^2 + 8 x y + y^3) = 0$

$1 + 2x - 3y + \lambda(x^2 + xy - y e^x) = 0$

*** Part 1 solve the linear problem
If $\lambda=1$ then we have the original nonlinear equations. If you set $\lambda=0$ though, you have a simple linear set of equations to solve. Find a solution to those equations for $\lambda=0$:

#+BEGIN_SRC ipython

#+END_SRC

This solution represents the solution to the equations when $\lambda=0$. If we could derive a set of equations for $\frac{dx}{d\lambda}$ and $\frac{dy}{d\lambda}$, then we can treat this linear solution as an initial value, and integrate the ODEs from $\lambda=0$ to $\lambda=1$ to find the solution to the nonlinear equations. In what follows, we motivate how to derive those equations.

*** Part 2 formulate a system of ODEs to solve the nonlinear problem

Next, we consider the equations as

$f(x, y) = 2 + x + y + \lambda(- x^2 + 8 x y + y^3) = 0$

$g(x, y) = 1 + 2x - 3y + \lambda(x^2 + xy - y e^x) = 0$

from calculus, you can show that:

$\frac{\partial f}{\partial x}\frac{\partial x}{\partial \lambda}+\frac{\partial f}{\partial y}\frac{\partial y}{\partial \lambda}=-\frac{\partial f}{\partial \lambda}$

$\frac{\partial g}{\partial x}\frac{\partial x}{\partial \lambda}+\frac{\partial g}{\partial y}\frac{\partial y}{\partial \lambda}=-\frac{\partial g}{\partial \lambda}$

You can rewrite this in a linear algebra form as:

\begin{equation}
\left[\begin{array}{cc}
\frac{\partial f}{\partial x} \frac{\partial f}{\partial y} \\
\frac{\partial g}{\partial x} \frac{\partial g}{\partial y}
\end{array}\right]
\left[\begin{array}{c}
\frac{\partial x}{\partial \lambda}\\
\frac{\partial y}{\partial \lambda}
\end{array}\right]
=
\left[\begin{array}{c}
-\frac{\partial f}{\partial \lambda}\\
-\frac{\partial g}{\partial \lambda}
\end{array}\right]
\end{equation}

The matrix on the left is the Jacobian of $F = [f(x,y), g(x, y)]$. This means you can solve for:

\[\left[\begin{array}{c}
\frac{\partial x}{\partial \lambda}\\
\frac{\partial y}{\partial \lambda}
\end{array}\right]
=
\mathbf{J}^{-1}
\left[\begin{array}{c}
-\frac{\partial f}{\partial \lambda}\\
-\frac{\partial g}{\partial \lambda}
\end{array}\right]\]

This last equation defines a set of differential equations that can be integrated from $\lambda=0$ where we know what (x, y) are, to $\lambda=1$ which leads to a solution to the original set of nonlinear equations!

Use the last equation to define a function for a system of ODEs, and then integrate the system of ODES from $\lambda=0$ to $\lambda=1$ to find the solution to the nonlinear set of equations. The solution is the value of $x, y$ at $\lambda=1$.

#+BEGIN_SRC ipython

#+END_SRC

*** Part 3 Verify the solution you found

Use a method of your choice to verify your solution from Part 2.

#+BEGIN_SRC ipython

#+END_SRC


** solution                                                        :solution:

The solution to the linear part is done like this:

#+BEGIN_SRC ipython
import numpy as np

x0 = np.linalg.solve([[1., 1.],
                      [2., -3.]],
                     [ -2, -1])
print(x0)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[8]:
# output
[-1.4 -0.6]

:END:

We need the jacobian of the function with respect to x,y and with respect to lambda. Here is one way to do this.

#+BEGIN_SRC ipython
import autograd.numpy as np
from autograd import jacobian

def F(X, L):
    x, y = X
    f = (2.0 + x + y) + L * (-x**2 + 8 * x * y + y**3)
    g = (1.0 + 2.0 * x - 3.0 * y) + L * (x**2 + x * y - y * np.exp(x))
    return np.array([f, g])

J = jacobian(F)
J(np.array([-1.4, -0.6]), 0.0)

dFdL = jacobian(F, 1)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[9]:
:END:

Then, we can define the ODE as written in the problem.

#+BEGIN_SRC ipython
def ode(X, L):
    x, y = X
    j = J(np.array([x, y]), L)
    dXdL = np.linalg.inv(j) @ -dFdL(np.array([x, y]), L)
    return dXdL

from scipy.integrate import odeint

lambda_span = np.linspace(0, 1, 1000)

X = odeint(ode, x0, lambda_span)

xsol, ysol = X[-1]
print('The solution is at x={0:1.3f}, y={1:1.3f}'.format(xsol, ysol))
print(F([xsol, ysol], 1))

plt.plot(lambda_span, X)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[13]:
# output
The solution is at x=-1.000, y=0.000
[ -1.27841341e-06  -1.15929141e-06]

# text/plain
: [<matplotlib.lines.Line2D at 0x11916f7b8>,
:  <matplotlib.lines.Line2D at 0x11916f940>]



# image/png
[[file:obipy-resources/73232f0e737f26c048822a8e09245932-50547ppk.png]]
:END:

The function is not super close to zero at the solution, primarily because of float tolerances in the ODE solver. You can see there is some stiff behavior near \lambda=0.17, so a different solver might be more accurate.

There are several ways to verify your solution. One is to solve it another way.

#+BEGIN_SRC ipython
from scipy.optimize import fsolve
fsolve(F, [-1, -0.01], args=(1,))
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[12]:
# text/plain
: array([ -1.00000000e+00,   3.27745564e-18])
:END:

* ASSIGNED exam3-4 optimization                      :optimization:nori:p2:2:
  CLOSED: [2018-12-10 Mon 11:48]
  :PROPERTIES:
  :LABEL:    exam3-4
  :POINTS:   2
  :TYPE:     exam-3
  :RUBRIC:   default
  :RUBRIC_CATEGORIES: technical, presentation
  :RUBRIC_WEIGHTS: 0.8, 0.2
  :DUEDATE:  2018-12-10 16:00:00
  :GRADER:   Noriyuki Yoshio
  :END:

*This is an exam. You must be present in the exam room to get credit for this problem unless you have prior permission from the instructor. You may not talk during the exam except to ask an instructor a question. By turning this in, you agree that this work is your own, and you did not get unauthorized help to complete it or provide unauthorized help to anyone else. You may not modify your exam answer after the due time without permission.*

The modified Rosenbrock equation:

$f(x_1, x_2) = 100 (x_2 - x_1^2)^2 + (6.4 (x_2 - 0.5)^2 - x_1 -0.6)^2$ has three minima in the range of $-2 < x_1 < 2$ and $-2 < x_2 < 2$. Find these minima and their values.

#+BEGIN_SRC ipython

#+END_SRC

** solution                                                        :solution:

The best way to do this is make a plot to see about where the minima are. They are marked by red dots below.

   #+BEGIN_SRC ipython
def f(X):
    x1, x2 = X
    return 100 * (x2 - x1**2)**2 + (6.4 * (x2 - 0.5)**2 - x1 - 0.6)**2

x = np.linspace(-2, 2)
X1, X2 = np.meshgrid(x, x)
F = f([X1, X2])
plt.contourf(X1, X2, F,
             levels=np.linspace(F.min(), F.min() + 2, 10))
plt.plot(-0.5, 0.3, 'ro')
plt.plot(0.4, 0.2, 'ro')
plt.plot(1.0, 1.0, 'ro')
plt.colorbar()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[19]:




# image/png
[[file:obipy-resources/73232f0e737f26c048822a8e09245932-50547cmS.png]]
:END:

Then use minimize near each one.

#+BEGIN_SRC ipython
from scipy.optimize import minimize
minimize(f, [-0.5, 0.3])
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[20]:
# text/plain
:       fun: 0.007415391415456604
:  hess_inv: array([[ 0.28018738, -0.3676456 ],
:        [-0.3676456 ,  0.48735567]])
:       jac: array([  6.43782550e-06,   4.43111639e-06])
:   message: 'Optimization terminated successfully.'
:      nfev: 48
:       nit: 9
:      njev: 12
:    status: 0
:   success: True
:         x: array([-0.66369981,  0.44114435])
:END:


#+BEGIN_SRC ipython
minimize(f, [0.4, 0.2])
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[21]:
# text/plain
:       fun: 3.2131113378272195e-14
:  hess_inv: array([[ 0.03242901,  0.01648846],
:        [ 0.01648846,  0.01239832]])
:       jac: array([  6.72972908e-08,   5.20208106e-07])
:   message: 'Optimization terminated successfully.'
:      nfev: 36
:       nit: 6
:      njev: 9
:    status: 0
:   success: True
:         x: array([ 0.34130746,  0.11649078])
:END:

#+BEGIN_SRC ipython
minimize(f, [1, 1])
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[22]:
# text/plain
:       fun: 1.2325951644078309e-32
:  hess_inv: array([[1, 0],
:        [0, 1]])
:       jac: array([  5.97536573e-06,   2.10046770e-06])
:   message: 'Optimization terminated successfully.'
:      nfev: 4
:       nit: 0
:      njev: 1
:    status: 0
:   success: True
:         x: array([ 1.,  1.])
:END:


* ASSIGNED exam3-5 BVP by ODE                             :bvp:ode:john:p3:3:
  CLOSED: [2018-12-10 Mon 11:52]
  :PROPERTIES:
  :LABEL:    exam3-5
  :POINTS:   3
  :TYPE:     exam-3
  :RUBRIC:   default
  :RUBRIC_CATEGORIES: technical, presentation
  :RUBRIC_WEIGHTS: 0.8, 0.2
  :DUEDATE:  2018-12-10 16:00:00
  :GRADER:   John Kitchin
  :END:

*This is an exam. You must be present in the exam room to get credit for this problem unless you have prior permission from the instructor. You may not talk during the exam except to ask an instructor a question. By turning this in, you agree that this work is your own, and you did not get unauthorized help to complete it or provide unauthorized help to anyone else. You may not modify your exam answer after the due time without permission.*

In this problem we learn a new way to solve a /linear/ boundary value problem. The problem of interest is:

$y'''(x) - x^2 y = -x^4$ with $y(0)=0, y'(0)=0, y(2)=4$.

This will take some steps, so read the following carefully. Some of these steps will be worked out, and others you will be asked to complete. You /do not need to derive these/, they are here to guide what you will do.

First, we recall that the general solution of a linear ODE can be written as a linear combination of solutions to the homogeneous equation (where the right hand side is zero) and a particular solution to the non-homogeneous equation (where the right hand side in this case is $-x^4$).

Here are the homogeneous versions and the particular version of the equation above, expressed in /initial value form/. The initial conditions are chosen here to provide three linearly independent functions $Y_1, Y_2$, and $Y_3$. For $Y_p$ any values can be used since any particular solution will do.

$Y_1''' - x^2 Y_1 = 0$ with $Y_1(0)=1, Y_1'(0)=0, Y_1''(0)=0$

$Y_2''' - x^2 Y_2 = 0$ with $Y_2(0)=0, Y_2'(0)=1, Y_2''(0)=0$

$Y_3''' - x^2 Y_3 = 0$ with $Y_3(0)=0, Y_3'(0)=0, Y_3''(0)=1$

$Y_p''' - x^2 Y_p = -x^4$ with $Y_p(0)=0, Y_p'(0)=0, Y_p''(0)=0$

These can be combined to form the general solution to the differential equation.

$y(x) = C_1 Y_1(x) + C_2 Y_2(x) + C_3 Y_3(x) + Y_p(x)$

To get towards a solution to the original BVP, we next apply the boundary conditions to find the constants $C_i$.

$y(0) = 0 = C_1 + 0 + 0 + 0$

$y'(0) = 0 = 0 + C_2 + 0 + 0$

$y(2) = 4 = C_1 Y_1(2) + C_2 Y_2(2) + C_3 Y_3(2) + Y_p(2)$

Combined, these lead to:

$y(x) = \frac{4 - Y_p(2)}{Y_3(2)} Y_3(x) + Y_p(x)$ where $Y_p(2)$ means the function $Y_p$ evaluated at $x=2$ and $Y_3(2)$ means the function $Y_3$ evaluated at $x=2$.

That is remarkably the solution to the boundary value problem originally stated, and we can now get $Y_3$ and $Y_p$ by integrating two /ordinary initial value/ differential equations!

** Solve for $Y_3$ and $Y_p$

Find solutions to these two initial value ODEs over the range of $x=0$ to $x=2$:

$Y_3''' - x^2 Y_3 = 0$ with $Y_3(0)=0, Y_3'(0)=0, Y_3''(0)=1$

Note that in the next step you will need to evaluate $Y_3(2)$ and $Y_p(2)$.

#+BEGIN_SRC ipython

#+END_SRC

$Y_p''' - x^2 Y_p = -x^4$ with $Y_p(0)=0, Y_p'(0)=0, Y_p''(0)=0$

#+BEGIN_SRC ipython

#+END_SRC

** Combine them to get a solution to the BVP

Use your solutions to create the overall solution. $Y_p(2)$ means evaluate $Y_p(x)$ at $x=2$. $Y_3(2)$ means evaluate $Y_3(x)$ at $x=2$. You can do this anyway you want.

$y(x) = \frac{4 - Y_p(2)}{Y_3(2)} Y_3(x) + Y_p(x)$

Make a plot of $y(x)$.

#+BEGIN_SRC ipython

#+END_SRC


** solution                                                        :solution:

First, we solve for Y3 and Yp. These get converted to a system of FODEs and then are integrated normally. You have two options for later, one is make sure the solutions are the same size in vector form so they can be added together, and the other is to use dense_output or make interpolating functions so they can be used to generate the vectors later..

#+BEGIN_SRC ipython
import numpy as np

xspan = np.linspace(0, 2, 500)

def y3prime(x, Y):
    y3, u3, v3 = Y
    y3prime = u3
    u3prime = v3
    v3prime = x**2 * y3
    return y3prime, u3prime, v3prime

from scipy.integrate import solve_ivp
y3 = solve_ivp(y3prime, (0, 2), [0, 0, 1], max_step=0.1, dense_output=True)
%matplotlib inline
import matplotlib.pyplot as plt
plt.plot(y3.t, y3.y[0])
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[23]:
# text/plain
: [<matplotlib.lines.Line2D at 0x119d7c320>]



# image/png
[[file:obipy-resources/73232f0e737f26c048822a8e09245932-50547pwY.png]]
:END:

#+BEGIN_SRC ipython
def ypprime(x, Y):
    yp, up, vp = Y
    ypprime = up
    upprime = vp
    vpprime = x**2 * yp - x**4
    return [ypprime, upprime, vpprime]

yp = solve_ivp(ypprime, (0, 2), [0, 0, 0], max_step=0.1, dense_output=True)
plt.plot(yp.t, yp.y[0])
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[24]:
# text/plain
: [<matplotlib.lines.Line2D at 0x119f854a8>]



# image/png
[[file:obipy-resources/73232f0e737f26c048822a8e09245932-5054726e.png]]
:END:

I used the dense_output approach. evaluate the solutions on the xspan.

#+BEGIN_SRC ipython
Y3 = y3.sol(xspan)[0]
Yp = yp.sol(xspan)[0]
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[26]:
:END:

and combine them.

#+BEGIN_SRC ipython
Y = (4 - yp.sol(2)[0]) / y3.sol(2)[0] * Y3 + Yp

%matplotlib inline
import matplotlib.pyplot as plt
plt.plot(xspan, Y)
plt.xlabel('x')
plt.ylabel('y')
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[28]:




# image/png
[[file:obipy-resources/73232f0e737f26c048822a8e09245932-50547QPr.png]]
:END:

Visually it appears the BCS are satisfied (0 at x=0, flat at x=0, and 4 at x=2).


* ASSIGNED exam3-6                            :quad:integration:mingjie:p1:2:
  CLOSED: [2018-12-10 Mon 11:53]
  :PROPERTIES:
  :LABEL:    exam3-6
  :POINTS:   2
  :TYPE:     exam-3
  :RUBRIC:   default
  :RUBRIC_CATEGORIES: technical, presentation
  :RUBRIC_WEIGHTS: 0.8, 0.2
  :DUEDATE:  2018-12-10 16:00:00
  :GRADER:   Mingjie Liu
  :END:

*This is an exam. You must be present in the exam room to get credit for this problem unless you have prior permission from the instructor. You may not talk during the exam except to ask an instructor a question. By turning this in, you agree that this work is your own, and you did not get unauthorized help to complete it or provide unauthorized help to anyone else. You may not modify your exam answer after the due time without permission.*

The \Gamma function is defined by:

$\Gamma(x) = \int_0^\infty e^{-t}t^{x-1} dt$

It is a generalized factorial function. When the arguments to the function are integers, the following relation is true:

$\Gamma(n + 1) = n!$

Show that this is true for the integers from 1 to 10. You can use the ~math.factorial~ function.

#+BEGIN_SRC ipython
from math import factorial

factorial(4)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[87]:
# text/plain
: 24
:END:

#+BEGIN_SRC ipython

#+END_SRC

** solution                                                        :solution:

We just need to setup the equations and integrals and then iterate over the integers.

#+BEGIN_SRC ipython
from math import factorial
from scipy.integrate import quad
import numpy as np

def integrand(t, x):
    return np.exp(-t) * t**(x - 1)

def Gamma(x):
    I, err = quad(integrand, 0, np.inf, args=(x, ))
    return I

for i in range(1, 11):
    print(i, Gamma(i), factorial(i - 1), np.allclose(Gamma(i), factorial(i - 1)))
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 # Out[29]:
 # output
 1 1.0000000000000002 1 True
 2 0.9999999999999998 1 True
 3 2.0 2 True
 4 6.0 6 True
 5 24.0 24 True
 6 120.00000000000001 120 True
 7 720.0000000000001 720 True
 8 5040.000000000001 5040 True
 9 40320.0 40320 True
 10 362879.99999999994 362880 True

 :END:
Within float tolerance, these are equal.
